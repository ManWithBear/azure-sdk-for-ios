// --------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for
// license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// --------------------------------------------------------------------------

import AzureCore
import Foundation

public enum TileFormat: RequestStringConvertible, Codable, Equatable {
    /// Custom value for unrecognized enum values
    case custom(String)
    /// An image in the png format. Supports zoom levels 0 through 18.
    case png
    /// Vector graphic in the pbf format. Supports zoom levels 0 through 22.
    case pbf

    public var requestString: String {
        switch self {
        case let .custom(val):
            return val
        case .png:
            return "png"
        case .pbf:
            return "pbf"
        }
    }

    public init(_ val: String) {
        switch val.lowercased() {
        case "png":
            self = .png
        case "pbf":
            self = .pbf
        default:
            self = .custom(val)
        }
    }

    // MARK: Codable

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let value = try container.decode(String.self)
        self.init(value)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(requestString)
    }
}

public enum TrafficFlowTileStyle: RequestStringConvertible, Codable, Equatable {
    /// Custom value for unrecognized enum values
    case custom(String)
    /// Colors will reflect the absolute speed measured. Absolute speed is the capability to access the full speed.
    case absolute
    /// This is the speed relative to free-flow, highlighting areas of congestion visualizing the traffic flow. Free-flow refers to conditions where there is no congestion and traffic can follow the speed limits. The most used option to visualize traffic flow on a map.
    case relative
    /// Displays relative colors only where they are different from the free-flow speeds. This option will only highlights areas of congestion.
    case relativeDelay
    /// Displays relative colors but a larger difference from freeflow is required for segments to change the color. This mode only valid when format is png.
    case reducedSensitivity

    public var requestString: String {
        switch self {
        case let .custom(val):
            return val
        case .absolute:
            return "absolute"
        case .relative:
            return "relative"
        case .relativeDelay:
            return "relative-delay"
        case .reducedSensitivity:
            return "reduced-sensitivity"
        }
    }

    public init(_ val: String) {
        switch val.lowercased() {
        case "absolute":
            self = .absolute
        case "relative":
            self = .relative
        case "relative-delay":
            self = .relativeDelay
        case "reduced-sensitivity":
            self = .reducedSensitivity
        default:
            self = .custom(val)
        }
    }

    // MARK: Codable

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let value = try container.decode(String.self)
        self.init(value)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(requestString)
    }
}

public enum ResponseFormat: RequestStringConvertible, Codable, Equatable {
    /// Custom value for unrecognized enum values
    case custom(String)
    /// [The JavaScript Object Notation Data Interchange Format](https://tools.ietf.org/html/rfc8259)
    case json
    /// [The Extensible Markup Language](https://www.w3.org/TR/xml/)
    case xml

    public var requestString: String {
        switch self {
        case let .custom(val):
            return val
        case .json:
            return "json"
        case .xml:
            return "xml"
        }
    }

    public init(_ val: String) {
        switch val.lowercased() {
        case "json":
            self = .json
        case "xml":
            self = .xml
        default:
            self = .custom(val)
        }
    }

    // MARK: Codable

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let value = try container.decode(String.self)
        self.init(value)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(requestString)
    }
}

public enum TrafficFlowSegmentStyle: RequestStringConvertible, Codable, Equatable {
    /// Custom value for unrecognized enum values
    case custom(String)

    case absolute

    case relative

    case relativeDelay

    public var requestString: String {
        switch self {
        case let .custom(val):
            return val
        case .absolute:
            return "absolute"
        case .relative:
            return "relative"
        case .relativeDelay:
            return "relative-delay"
        }
    }

    public init(_ val: String) {
        switch val.lowercased() {
        case "absolute":
            self = .absolute
        case "relative":
            self = .relative
        case "relative-delay":
            self = .relativeDelay
        default:
            self = .custom(val)
        }
    }

    // MARK: Codable

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let value = try container.decode(String.self)
        self.init(value)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(requestString)
    }
}

public enum SpeedUnit: RequestStringConvertible, Codable, Equatable {
    /// Custom value for unrecognized enum values
    case custom(String)
    /// Kilometers Per Hour
    case kmph
    /// Miles Per Hour
    case mPH

    public var requestString: String {
        switch self {
        case let .custom(val):
            return val
        case .kmph:
            return "KMPH"
        case .mPH:
            return "MPH"
        }
    }

    public init(_ val: String) {
        switch val.lowercased() {
        case "kmph":
            self = .kmph
        case "mph":
            self = .mPH
        default:
            self = .custom(val)
        }
    }

    // MARK: Codable

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let value = try container.decode(String.self)
        self.init(value)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(requestString)
    }
}

public enum TrafficIncidentTileStyle: RequestStringConvertible, Codable, Equatable {
    /// Custom value for unrecognized enum values
    case custom(String)
    /// Creates traffic lines with colored chevrons indicating severity.
    case s1
    /// Creates plain lines with certain degree of glow.
    case s2
    /// Creates plain lines with certain degree of glow, different from the s2 style.
    case s3
    /// Night style.
    case night

    public var requestString: String {
        switch self {
        case let .custom(val):
            return val
        case .s1:
            return "s1"
        case .s2:
            return "s2"
        case .s3:
            return "s3"
        case .night:
            return "night"
        }
    }

    public init(_ val: String) {
        switch val.lowercased() {
        case "s1":
            self = .s1
        case "s2":
            self = .s2
        case "s3":
            self = .s3
        case "night":
            self = .night
        default:
            self = .custom(val)
        }
    }

    // MARK: Codable

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let value = try container.decode(String.self)
        self.init(value)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(requestString)
    }
}

public enum IncidentDetailStyle: RequestStringConvertible, Codable, Equatable {
    /// Custom value for unrecognized enum values
    case custom(String)
    /// Creates traffic lines with colored chevrons indicating severity.
    case s1
    /// Creates plain lines with certain degree of glow.
    case s2
    /// Creates plain lines with certain degree of glow, different than the s2 style.
    case s3
    /// Night style.
    case night

    public var requestString: String {
        switch self {
        case let .custom(val):
            return val
        case .s1:
            return "s1"
        case .s2:
            return "s2"
        case .s3:
            return "s3"
        case .night:
            return "night"
        }
    }

    public init(_ val: String) {
        switch val.lowercased() {
        case "s1":
            self = .s1
        case "s2":
            self = .s2
        case "s3":
            self = .s3
        case "night":
            self = .night
        default:
            self = .custom(val)
        }
    }

    // MARK: Codable

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let value = try container.decode(String.self)
        self.init(value)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(requestString)
    }
}

public enum ProjectionStandard: RequestStringConvertible, Codable, Equatable {
    /// Custom value for unrecognized enum values
    case custom(String)
    /// [EPSG900913](http://docs.openlayers.org/library/spherical_mercator.html)
    case epsg900913
    /// [EPSG4326](http://spatialreference.org/ref/epsg/4326/)
    case epsg4326

    public var requestString: String {
        switch self {
        case let .custom(val):
            return val
        case .epsg900913:
            return "EPSG900913"
        case .epsg4326:
            return "EPSG4326"
        }
    }

    public init(_ val: String) {
        switch val.lowercased() {
        case "epsg900913":
            self = .epsg900913
        case "epsg4326":
            self = .epsg4326
        default:
            self = .custom(val)
        }
    }

    // MARK: Codable

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let value = try container.decode(String.self)
        self.init(value)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(requestString)
    }
}

public enum IncidentGeometryType: RequestStringConvertible, Codable, Equatable {
    /// Custom value for unrecognized enum values
    case custom(String)
    /// Places incidents precisely on the road.
    case original
    /// Moves the incident slightly (depending on zoom level) to indicate specific road lanes.
    case shifted

    public var requestString: String {
        switch self {
        case let .custom(val):
            return val
        case .original:
            return "original"
        case .shifted:
            return "shifted"
        }
    }

    public init(_ val: String) {
        switch val.lowercased() {
        case "original":
            self = .original
        case "shifted":
            self = .shifted
        default:
            self = .custom(val)
        }
    }

    // MARK: Codable

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let value = try container.decode(String.self)
        self.init(value)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(requestString)
    }
}

/// The icon category associated with this incident. Values are numbers in the range 0-13, with the following meanings -- 0: Unknown, 1: Accident, 2: Fog, 3: Dangerous Conditions, 4: Rain, 5: Ice, 6: Jam, 7: Lane Closed, 8: Road Closed, 9: Road Works, 10: Wind, 11: Flooding, 12: Detour, 13: Cluster
public indirect enum IconCategory: RequestStringConvertible, Codable, Equatable {
    /// Custom value for unrecognized enum values
    case custom(String)
    /// Unknown
    case unknown
    /// Accident
    case accident
    /// Fog
    case fog
    /// Dangerous Conditions
    case dangerousConditions
    /// Rain
    case rain
    /// Ice
    case ice
    /// Jam
    case jam
    /// Lane Closed
    case laneClosed
    /// Road Closed
    case roadClosed
    /// Road Works
    case roadWorks
    /// Wind
    case wind
    /// Flooding
    case flooding
    /// Detour
    case detour
    /// Cluster: Returned if a cluster contains incidents with different icon categories.
    case cluster
    /// Broken Down Vehicle
    case brokenDownVehicle

    public var requestString: String {
        switch self {
        case let .custom(val):
            return val
        case .unknown:
            return "0"
        case .accident:
            return "1"
        case .fog:
            return "2"
        case .dangerousConditions:
            return "3"
        case .rain:
            return "4"
        case .ice:
            return "5"
        case .jam:
            return "6"
        case .laneClosed:
            return "7"
        case .roadClosed:
            return "8"
        case .roadWorks:
            return "9"
        case .wind:
            return "10"
        case .flooding:
            return "11"
        case .detour:
            return "12"
        case .cluster:
            return "13"
        case .brokenDownVehicle:
            return "14"
        }
    }

    public init(_ val: String) {
        switch val.lowercased() {
        case "0":
            self = .unknown
        case "1":
            self = .accident
        case "2":
            self = .fog
        case "3":
            self = .dangerousConditions
        case "4":
            self = .rain
        case "5":
            self = .ice
        case "6":
            self = .jam
        case "7":
            self = .laneClosed
        case "8":
            self = .roadClosed
        case "9":
            self = .roadWorks
        case "10":
            self = .wind
        case "11":
            self = .flooding
        case "12":
            self = .detour
        case "13":
            self = .cluster
        case "14":
            self = .brokenDownVehicle
        default:
            self = .custom(val)
        }
    }

    // MARK: Codable

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let value = try container.decode(String.self)
        self.init(value)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(requestString)
    }
}

/// The magnitude of delay associated with incident. These values correspond to incident colors in the traffic tiles
public enum DelayMagnitude: RequestStringConvertible, Codable, Equatable {
    /// Custom value for unrecognized enum values
    case custom(String)
    /// Unknown
    case unknown
    /// Minor
    case minor
    /// Moderate
    case moderate
    /// Major
    case major
    /// Indefinite (used for road closures and other indefinite delays)
    case indefinite

    public var requestString: String {
        switch self {
        case let .custom(val):
            return val
        case .unknown:
            return "0"
        case .minor:
            return "1"
        case .moderate:
            return "2"
        case .major:
            return "3"
        case .indefinite:
            return "4"
        }
    }

    public init(_ val: String) {
        switch val.lowercased() {
        case "0":
            self = .unknown
        case "1":
            self = .minor
        case "2":
            self = .moderate
        case "3":
            self = .major
        case "4":
            self = .indefinite
        default:
            self = .custom(val)
        }
    }

    // MARK: Codable

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let value = try container.decode(String.self)
        self.init(value)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(requestString)
    }
}
