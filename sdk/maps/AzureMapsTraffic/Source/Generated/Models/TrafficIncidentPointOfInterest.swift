// --------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for
// license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// --------------------------------------------------------------------------

import AzureCore
import Foundation
// swiftlint:disable superfluous_disable_command
// swiftlint:disable identifier_name
// swiftlint:disable line_length
// swiftlint:disable cyclomatic_complexity

public struct TrafficIncidentPointOfInterest: Codable {
    // MARK: Properties

    /// ID of the traffic incident
    public let id: String?
    /// The point where an icon of the cluster or raw incident should be drawn, expressed in the requested projection. This is affected by traffic style, zoom level and road type
    public let point: Point?
    /// The icon category associated with this incident. Values are numbers in the range 0-13, with the following meanings -- 0: Unknown, 1: Accident, 2: Fog, 3: Dangerous Conditions, 4: Rain, 5: Ice, 6: Jam, 7: Lane Closed, 8: Road Closed, 9: Road Works, 10: Wind, 11: Flooding, 12: Detour, 13: Cluster
    public let iconCategory: IconCategory?
    /// The magnitude of delay associated with incident. These values correspond to incident colors in the traffic tiles
    public let magnitudeOfDelay: DelayMagnitude?
    /// Bottom left coordinate of the cluster in the projection of the request
    public let bottomLeftCoordinate: Point?
    /// Top right coordinate of the cluster in the projection of the request
    public let topLeftCoordinate: Point?
    /// Cluster size: the number of incidents in the cluster
    public let clusterSize: Int32?
    /// Length of the incident in meters
    public let lengthInMeters: Int32?
    /// The road number(s) affected by the incident. Multiple road numbers will delimited by slashes
    public let roadNumbers: String?
    /// Start date of the incident, if available. The date is described in the ISO8601 format.
    public let startDate: Iso8601Date?
    /// Estimated end date of the incident, if available. The date is described in the ISO8601 format.
    public let endDate: Iso8601Date?
    /// Delay caused by the incident in seconds (except in road closures)
    public let delayInSeconds: Int32?
    /// To: the name of the intersection or location where the traffic due to the incident ends
    public let trafficEndLocation: String?
    /// From: the name of the intersection or location where the traffic due to the incident starts
    public let trafficStartLocation: String?
    /// Description of the incident in the language requested
    public let description: String?
    /// Cause of the incident, where available, in the language requested
    public let cause: String?

    // MARK: Initializers

    /// Initialize a `TrafficIncidentPointOfInterest` structure.
    /// - Parameters:
    ///   - id: ID of the traffic incident
    ///   - point: The point where an icon of the cluster or raw incident should be drawn, expressed in the requested projection. This is affected by traffic style, zoom level and road type
    ///   - iconCategory: The icon category associated with this incident. Values are numbers in the range 0-13, with the following meanings -- 0: Unknown, 1: Accident, 2: Fog, 3: Dangerous Conditions, 4: Rain, 5: Ice, 6: Jam, 7: Lane Closed, 8: Road Closed, 9: Road Works, 10: Wind, 11: Flooding, 12: Detour, 13: Cluster
    ///   - magnitudeOfDelay: The magnitude of delay associated with incident. These values correspond to incident colors in the traffic tiles
    ///   - bottomLeftCoordinate: Bottom left coordinate of the cluster in the projection of the request
    ///   - topLeftCoordinate: Top right coordinate of the cluster in the projection of the request
    ///   - clusterSize: Cluster size: the number of incidents in the cluster
    ///   - lengthInMeters: Length of the incident in meters
    ///   - roadNumbers: The road number(s) affected by the incident. Multiple road numbers will delimited by slashes
    ///   - startDate: Start date of the incident, if available. The date is described in the ISO8601 format.
    ///   - endDate: Estimated end date of the incident, if available. The date is described in the ISO8601 format.
    ///   - delayInSeconds: Delay caused by the incident in seconds (except in road closures)
    ///   - trafficEndLocation: To: the name of the intersection or location where the traffic due to the incident ends
    ///   - trafficStartLocation: From: the name of the intersection or location where the traffic due to the incident starts
    ///   - description: Description of the incident in the language requested
    ///   - cause: Cause of the incident, where available, in the language requested
    public init(
        id: String? = nil, point: Point? = nil, iconCategory: IconCategory? = nil,
        magnitudeOfDelay: DelayMagnitude? = nil,
        bottomLeftCoordinate: Point? = nil, topLeftCoordinate: Point? = nil, clusterSize: Int32? = nil,
        lengthInMeters: Int32? = nil, roadNumbers: String? = nil, startDate: Iso8601Date? = nil,
        endDate: Iso8601Date? = nil, delayInSeconds: Int32? = nil, trafficEndLocation: String? = nil,
        trafficStartLocation: String? = nil, description: String? = nil, cause: String? = nil
    ) {
        self.id = id
        self.point = point
        self.iconCategory = iconCategory
        self.magnitudeOfDelay = magnitudeOfDelay
        self.bottomLeftCoordinate = bottomLeftCoordinate
        self.topLeftCoordinate = topLeftCoordinate
        self.clusterSize = clusterSize
        self.lengthInMeters = lengthInMeters
        self.roadNumbers = roadNumbers
        self.startDate = startDate
        self.endDate = endDate
        self.delayInSeconds = delayInSeconds
        self.trafficEndLocation = trafficEndLocation
        self.trafficStartLocation = trafficStartLocation
        self.description = description
        self.cause = cause
    }

    // MARK: Codable

    enum CodingKeys: String, CodingKey {
        case id = "id"
        case point = "p"
        case iconCategory = "ic"
        case magnitudeOfDelay = "ty"
        case bottomLeftCoordinate = "cbl"
        case topLeftCoordinate = "ctr"
        case clusterSize = "cs"
        case lengthInMeters = "l"
        case roadNumbers = "r"
        case startDate = "sd"
        case endDate = "ed"
        case delayInSeconds = "dl"
        case trafficEndLocation = "t"
        case trafficStartLocation = "f"
        case description = "d"
        case cause = "c"
    }

    /// Initialize a `TrafficIncidentPointOfInterest` structure from decoder
    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.id = try? container.decode(String.self, forKey: .id)
        self.point = try? container.decode(Point.self, forKey: .point)
        self.iconCategory = try? container.decode(IconCategory.self, forKey: .iconCategory)
        self.magnitudeOfDelay = try? container.decode(DelayMagnitude.self, forKey: .magnitudeOfDelay)
        self.bottomLeftCoordinate = try? container.decode(Point.self, forKey: .bottomLeftCoordinate)
        self.topLeftCoordinate = try? container.decode(Point.self, forKey: .topLeftCoordinate)
        self.clusterSize = try? container.decode(Int32.self, forKey: .clusterSize)
        self.lengthInMeters = try? container.decode(Int32.self, forKey: .lengthInMeters)
        self.roadNumbers = try? container.decode(String.self, forKey: .roadNumbers)
        self.startDate = try? container.decode(Iso8601Date.self, forKey: .startDate)
        self.endDate = try? container.decode(Iso8601Date.self, forKey: .endDate)
        self.delayInSeconds = try? container.decode(Int32.self, forKey: .delayInSeconds)
        self.trafficEndLocation = try? container.decode(String.self, forKey: .trafficEndLocation)
        self.trafficStartLocation = try? container.decode(String.self, forKey: .trafficStartLocation)
        self.description = try? container.decode(String.self, forKey: .description)
        self.cause = try? container.decode(String.self, forKey: .cause)
    }

    /// Encode a `TrafficIncidentPointOfInterest` structure
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        if id != nil { try? container.encode(id, forKey: .id) }
        if point != nil { try? container.encode(point, forKey: .point) }
        if iconCategory != nil { try? container.encode(iconCategory, forKey: .iconCategory) }
        if magnitudeOfDelay != nil { try? container.encode(magnitudeOfDelay, forKey: .magnitudeOfDelay) }
        if bottomLeftCoordinate != nil { try? container.encode(bottomLeftCoordinate, forKey: .bottomLeftCoordinate) }
        if topLeftCoordinate != nil { try? container.encode(topLeftCoordinate, forKey: .topLeftCoordinate) }
        if clusterSize != nil { try? container.encode(clusterSize, forKey: .clusterSize) }
        if lengthInMeters != nil { try? container.encode(lengthInMeters, forKey: .lengthInMeters) }
        if roadNumbers != nil { try? container.encode(roadNumbers, forKey: .roadNumbers) }
        if startDate != nil { try? container.encode(startDate, forKey: .startDate) }
        if endDate != nil { try? container.encode(endDate, forKey: .endDate) }
        if delayInSeconds != nil { try? container.encode(delayInSeconds, forKey: .delayInSeconds) }
        if trafficEndLocation != nil { try? container.encode(trafficEndLocation, forKey: .trafficEndLocation) }
        if trafficStartLocation != nil { try? container.encode(trafficStartLocation, forKey: .trafficStartLocation) }
        if description != nil { try? container.encode(description, forKey: .description) }
        if cause != nil { try? container.encode(cause, forKey: .cause) }
    }
}
