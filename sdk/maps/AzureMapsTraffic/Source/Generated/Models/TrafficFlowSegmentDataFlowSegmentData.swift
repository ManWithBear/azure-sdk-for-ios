// --------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for
// license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// --------------------------------------------------------------------------

import AzureCore
import Foundation
// swiftlint:disable superfluous_disable_command
// swiftlint:disable identifier_name
// swiftlint:disable line_length
// swiftlint:disable cyclomatic_complexity

/// Flow Segment Data property
public struct TrafficFlowSegmentDataFlowSegmentData: Codable {
    // MARK: Properties

    /// Functional Road Class. This indicates the road type:
    ///   0: Motorway, freeway or other major road.
    ///   1: Major road, less important than a motorway.
    ///   2: Other major road.
    ///   3: Secondary road.
    ///   4: Local connecting road.
    ///   5: Local road of high importance.
    ///   6: Local road.
    public let functionalRoadClass: String?
    /// The current average speed at the selected point, in the units requested. This is calculated from the currentTravelTime and the length of the selected segment.
    public let currentSpeed: Int32?
    /// The free flow speed expected under ideal conditions, expressed in the units requested. This is related to the freeFlowTravelTime.
    public let freeFlowSpeed: Int32?
    /// Current travel time in seconds, across this traffic segment, based on fused real-time measurements between the defined locations in the specified direction.
    public let currentTravelTime: Int32?
    /// The travel time in seconds, across this traffic segment, which would be expected under ideal free flow conditions.
    public let freeFlowTravelTime: Int32?
    /// The confidence is a measure of the quality of the provided travel time and speed. A value of 1 means full confidence, that the response contains the highest quality data.  Lower values indicate the degree that the response may vary from the actual conditions on the road. Any value greater than 0.6 means the information was based on real-time probe input. A value of 0.5 means the reported speed is based on historical info.   A value between 0.5 and 0.6 has a calculated weighted average between historical and live speeds.
    public let confidence: Float?
    /// Includes the coordinates describing the shape of the segment. Coordinates are shifted from the road depending on the zoom level to support high quality visualization in every scale.
    public let coordinates: TrafficFlowSegmentDataFlowSegmentDataCoordinates?
    /// This indicates the software version that generated the response.
    public let version: String?
    /// OpenLR code for segment. See [OpenLR](https://en.wikipedia.org/wiki/OpenLR) for more information on the use of Open LR codes.
    public let openLrCode: String?

    // MARK: Initializers

    /// Initialize a `TrafficFlowSegmentDataFlowSegmentData` structure.
    /// - Parameters:
    ///   - functionalRoadClass: Functional Road Class. This indicates the road type:
    ///   0: Motorway, freeway or other major road.
    ///   1: Major road, less important than a motorway.
    ///   2: Other major road.
    ///   3: Secondary road.
    ///   4: Local connecting road.
    ///   5: Local road of high importance.
    ///   6: Local road.
    ///   - currentSpeed: The current average speed at the selected point, in the units requested. This is calculated from the currentTravelTime and the length of the selected segment.
    ///   - freeFlowSpeed: The free flow speed expected under ideal conditions, expressed in the units requested. This is related to the freeFlowTravelTime.
    ///   - currentTravelTime: Current travel time in seconds, across this traffic segment, based on fused real-time measurements between the defined locations in the specified direction.
    ///   - freeFlowTravelTime: The travel time in seconds, across this traffic segment, which would be expected under ideal free flow conditions.
    ///   - confidence: The confidence is a measure of the quality of the provided travel time and speed. A value of 1 means full confidence, that the response contains the highest quality data.  Lower values indicate the degree that the response may vary from the actual conditions on the road. Any value greater than 0.6 means the information was based on real-time probe input. A value of 0.5 means the reported speed is based on historical info.   A value between 0.5 and 0.6 has a calculated weighted average between historical and live speeds.
    ///   - coordinates: Includes the coordinates describing the shape of the segment. Coordinates are shifted from the road depending on the zoom level to support high quality visualization in every scale.
    ///   - version: This indicates the software version that generated the response.
    ///   - openLrCode: OpenLR code for segment. See [OpenLR](https://en.wikipedia.org/wiki/OpenLR) for more information on the use of Open LR codes.
    public init(
        functionalRoadClass: String? = nil, currentSpeed: Int32? = nil, freeFlowSpeed: Int32? = nil,
        currentTravelTime: Int32? = nil, freeFlowTravelTime: Int32? = nil, confidence: Float? = nil,
        coordinates: TrafficFlowSegmentDataFlowSegmentDataCoordinates? = nil, version: String? = nil,
        openLrCode: String? = nil
    ) {
        self.functionalRoadClass = functionalRoadClass
        self.currentSpeed = currentSpeed
        self.freeFlowSpeed = freeFlowSpeed
        self.currentTravelTime = currentTravelTime
        self.freeFlowTravelTime = freeFlowTravelTime
        self.confidence = confidence
        self.coordinates = coordinates
        self.version = version
        self.openLrCode = openLrCode
    }

    // MARK: Codable

    enum CodingKeys: String, CodingKey {
        case functionalRoadClass = "frc"
        case currentSpeed = "currentSpeed"
        case freeFlowSpeed = "freeFlowSpeed"
        case currentTravelTime = "currentTravelTime"
        case freeFlowTravelTime = "freeFlowTravelTime"
        case confidence = "confidence"
        case coordinates = "coordinates"
        case version = "@version"
        case openLrCode = "openlr"
    }

    /// Initialize a `TrafficFlowSegmentDataFlowSegmentData` structure from decoder
    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.functionalRoadClass = try? container.decode(String.self, forKey: .functionalRoadClass)
        self.currentSpeed = try? container.decode(Int32.self, forKey: .currentSpeed)
        self.freeFlowSpeed = try? container.decode(Int32.self, forKey: .freeFlowSpeed)
        self.currentTravelTime = try? container.decode(Int32.self, forKey: .currentTravelTime)
        self.freeFlowTravelTime = try? container.decode(Int32.self, forKey: .freeFlowTravelTime)
        self.confidence = try? container.decode(Float.self, forKey: .confidence)
        self.coordinates = try? container.decode(
            TrafficFlowSegmentDataFlowSegmentDataCoordinates.self,
            forKey: .coordinates
        )
        self.version = try? container.decode(String.self, forKey: .version)
        self.openLrCode = try? container.decode(String.self, forKey: .openLrCode)
    }

    /// Encode a `TrafficFlowSegmentDataFlowSegmentData` structure
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        if functionalRoadClass != nil { try? container.encode(functionalRoadClass, forKey: .functionalRoadClass) }
        if currentSpeed != nil { try? container.encode(currentSpeed, forKey: .currentSpeed) }
        if freeFlowSpeed != nil { try? container.encode(freeFlowSpeed, forKey: .freeFlowSpeed) }
        if currentTravelTime != nil { try? container.encode(currentTravelTime, forKey: .currentTravelTime) }
        if freeFlowTravelTime != nil { try? container.encode(freeFlowTravelTime, forKey: .freeFlowTravelTime) }
        if confidence != nil { try? container.encode(confidence, forKey: .confidence) }
        if coordinates != nil { try? container.encode(coordinates, forKey: .coordinates) }
        if version != nil { try? container.encode(version, forKey: .version) }
        if openLrCode != nil { try? container.encode(openLrCode, forKey: .openLrCode) }
    }
}
