// --------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for
// license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// --------------------------------------------------------------------------

import AzureCore
import Foundation
// swiftlint:disable superfluous_disable_command
// swiftlint:disable file_length
// swiftlint:disable cyclomatic_complexity
// swiftlint:disable function_body_length
// swiftlint:disable type_body_length

internal final class Traffic {
    internal let client: TrafficClientInternal

    init(client: TrafficClientInternal) {
        self.client = client
    }

    /// __Traffic Flow Tile__
    /// **Applies to**: S0 and S1 pricing tiers.
    /// The Azure Flow Tile API serves 256 x 256 pixel tiles showing traffic flow. All tiles use the same grid system. Because the traffic tiles use transparent images, they can be layered on top of map tiles to create a compound  display. The Flow tiles use colors to indicate either the speed of traffic on different road segments, or the difference between that speed and the free-flow speed on the road segment in question.
    /// - Parameters:
    ///    - format : Desired format of the response. Possible values are png & pbf.
    ///    - style : <p>The style to be used to render the tile.</p>
    ///    - zoom : Zoom level for the desired tile. For _raster_ tiles, value must be in the range: 0-22 (inclusive). For _vector_ tiles, value must be in the range: 0-22 (inclusive).
    /// Please see [Zoom Levels and Tile Grid](https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid) for details.
    ///    - tileIndex : Parameter group
    ///    - options: A list of options for the operation
    ///    - completionHandler: A completion handler that receives a status code on
    ///     success.
    internal func getTrafficFlowTile(
        format: TileFormat,
        style: TrafficFlowTileStyle,
        zoom: Int32,
        tileIndex: TileIndex,
        withOptions options: GetTrafficFlowTileOptions? = nil,
        completionHandler: @escaping HTTPResultHandler<Void>
    ) {
        let dispatchQueue = options?.dispatchQueue ?? client.commonOptions.dispatchQueue ?? DispatchQueue.main

        // Create request parameters
        let params = RequestParameters(
            (.path, "format", format, .encode), (.query, "style", style, .encode), (.query, "zoom", zoom, .encode),
            (.query, "thickness", options?.thickness, .encode),
            (.uri, "$host", client.endpoint.absoluteString, .skipEncoding),
            (.header, "x-ms-client-id", client.clientId, .encode),
            (.query, "api-version", client.options.apiVersion, .encode), (.query, "x", tileIndex.x, .encode),
            (.query, "y", tileIndex.y, .encode), (
                .header,
                "Accept",
                "image/jpeg, image/png, image/pbf, application/vnd.mapbox-vector-tile, application/json",
                .encode
            )
        )

        // Construct request
        let urlTemplate = "/traffic/flow/tile/{format}"
        guard let requestUrl = client.url(host: "{$host}", template: urlTemplate, params: params),
            let request = try? HTTPRequest(method: .get, url: requestUrl, headers: params.headers)
        else {
            client.options.logger.error("Failed to construct HTTP request.")
            return
        }

        // Apply client-side validation
        var validationErrors = [String]()
        // Validate thickness
        if let thickness = options?.thickness, thickness > 20 {
            validationErrors.append("thickness: <= 20")
        }
        if let thickness = options?.thickness, thickness < 1 {
            validationErrors.append("thickness: >= 1")
        }
        if !validationErrors.isEmpty {
            dispatchQueue.async {
                let error = AzureError.client("Validation Errors: \(validationErrors.joined(separator: ", "))")
                completionHandler(.failure(error), nil)
            }
            return
        }

        // Send request
        let context = PipelineContext.of(keyValues: [
            ContextKey.allowedStatusCodes.rawValue: [200] as AnyObject
        ])
        context.add(cancellationToken: options?.cancellationToken, applying: client.options)
        context.merge(with: options?.context)
        client.request(request, context: context) { result, httpResponse in
            guard let data = httpResponse?.data else {
                let noDataError = AzureError.client("Response data expected but not found.")
                dispatchQueue.async {
                    completionHandler(.failure(noDataError), httpResponse)
                }
                return
            }
            switch result {
            case .success:
                guard let statusCode = httpResponse?.statusCode else {
                    let noStatusCodeError = AzureError.client("Expected a status code in response but didn't find one.")
                    dispatchQueue.async {
                        completionHandler(.failure(noStatusCodeError), httpResponse)
                    }
                    return
                }
                if [
                    200
                ].contains(statusCode) {
                    dispatchQueue.async {
                        completionHandler(
                            .success(()),
                            httpResponse
                        )
                    }
                }
            case .failure:
                do {
                    let decoder = JSONDecoder()
                    let decoded = try decoder.decode(ErrorResponse.self, from: data)
                    dispatchQueue.async {
                        completionHandler(
                            .failure(AzureError.service("An unexpected error occurred.", decoded)),
                            httpResponse
                        )
                    }
                } catch {
                    dispatchQueue.async {
                        completionHandler(.failure(AzureError.client("Decoding error.", error)), httpResponse)
                    }
                }
            }
        }
    }

    /// __Traffic Flow Segment__
    /// **Applies to**: S0 and S1 pricing tiers.
    /// This service provides information about the speeds and travel times of the road fragment closest to the given coordinates. It is designed to work alongside the Flow layer of the Render Service to support clickable  flow data visualizations. With this API, the client side can connect any place in the map with flow data on the  closest road and present it to the user.
    /// - Parameters:
    ///    - format : Desired format of the response. Value can be either _json_ or _xml_.
    ///    - style : The style to be used to render the tile. Valid values are absolute which returns colors reflecting the absolute speed measured, relative which returns the speed relative to free-flow, Relative-delay which displays relative speeds only where they are different from the freeflow speeds
    ///    - zoom : Zoom level for the desired tile. Zoom value must be in the range: 0-22 (inclusive).
    /// Please see [Zoom Levels and Tile Grid](https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid) for details.
    ///    - coordinates : Coordinates of the point close to the road segment. This parameter is a list of four coordinates, containing two coordinate pairs (lat, long, lat, long), and calculated using EPSG4326 projection. When this endpoint is called directly, coordinates are passed in as a single string containing four coordinates, separated by commas.
    ///    - options: A list of options for the operation
    ///    - completionHandler: A completion handler that receives a status code on
    ///     success.
    internal func getTrafficFlowSegment(
        format: ResponseFormat,
        style: TrafficFlowSegmentStyle,
        zoom: Int32,
        coordinates: [Double],
        withOptions options: GetTrafficFlowSegmentOptions? = nil,
        completionHandler: @escaping HTTPResultHandler<TrafficFlowSegmentData>
    ) {
        let dispatchQueue = options?.dispatchQueue ?? client.commonOptions.dispatchQueue ?? DispatchQueue.main

        // Create request parameters
        let params = RequestParameters(
            (.path, "format", format, .encode), (.query, "style", style, .encode), (.query, "zoom", zoom, .encode),
            (.query, "query", coordinates.map { "\($0)" }.joined(separator: ","), .encode),
            (.query, "unit", options?.unit, .encode), (.query, "thickness", options?.thickness, .encode),
            (.query, "openLr", options?.openLr, .encode),
            (.uri, "$host", client.endpoint.absoluteString, .skipEncoding),
            (.header, "x-ms-client-id", client.clientId, .encode),
            (.query, "api-version", client.options.apiVersion, .encode),
            (.header, "Accept", "application/json", .encode)
        )

        // Construct request
        let urlTemplate = "/traffic/flow/segment/{format}"
        guard let requestUrl = client.url(host: "{$host}", template: urlTemplate, params: params),
            let request = try? HTTPRequest(method: .get, url: requestUrl, headers: params.headers)
        else {
            client.options.logger.error("Failed to construct HTTP request.")
            return
        }

        // Apply client-side validation
        var validationErrors = [String]()
        // Validate coordinates
        if coordinates.count > 2 {
            validationErrors.append("coordinates: maxItems 2")
        }
        if coordinates.count < 2 {
            validationErrors.append("coordinates: minItems 2")
        }
        // Validate thickness
        if let thickness = options?.thickness, thickness > 20 {
            validationErrors.append("thickness: <= 20")
        }
        if let thickness = options?.thickness, thickness < 1 {
            validationErrors.append("thickness: >= 1")
        }
        if !validationErrors.isEmpty {
            dispatchQueue.async {
                let error = AzureError.client("Validation Errors: \(validationErrors.joined(separator: ", "))")
                completionHandler(.failure(error), nil)
            }
            return
        }

        // Send request
        let context = PipelineContext.of(keyValues: [
            ContextKey.allowedStatusCodes.rawValue: [200] as AnyObject
        ])
        context.add(cancellationToken: options?.cancellationToken, applying: client.options)
        context.merge(with: options?.context)
        client.request(request, context: context) { result, httpResponse in
            guard let data = httpResponse?.data else {
                let noDataError = AzureError.client("Response data expected but not found.")
                dispatchQueue.async {
                    completionHandler(.failure(noDataError), httpResponse)
                }
                return
            }
            switch result {
            case .success:
                guard let statusCode = httpResponse?.statusCode else {
                    let noStatusCodeError = AzureError.client("Expected a status code in response but didn't find one.")
                    dispatchQueue.async {
                        completionHandler(.failure(noStatusCodeError), httpResponse)
                    }
                    return
                }
                if [
                    200
                ].contains(statusCode) {
                    do {
                        let decoder = JSONDecoder()
                        let decoded = try decoder.decode(TrafficFlowSegmentData.self, from: data)
                        dispatchQueue.async {
                            completionHandler(.success(decoded), httpResponse)
                        }
                    } catch {
                        dispatchQueue.async {
                            completionHandler(.failure(AzureError.client("Decoding error.", error)), httpResponse)
                        }
                    }
                }
            case .failure:
                do {
                    let decoder = JSONDecoder()
                    let decoded = try decoder.decode(ErrorResponse.self, from: data)
                    dispatchQueue.async {
                        completionHandler(
                            .failure(AzureError.service("An unexpected error occurred.", decoded)),
                            httpResponse
                        )
                    }
                } catch {
                    dispatchQueue.async {
                        completionHandler(.failure(AzureError.client("Decoding error.", error)), httpResponse)
                    }
                }
            }
        }
    }

    /// __Traffic Incident Tile__
    /// **Applies to**: S0 and S1 pricing tiers.
    /// This service serves 256 x 256 pixel tiles showing traffic incidents. All tiles use the same grid system. Because the traffic tiles use transparent images, they can be layered on top of map tiles to create a compound display. Traffic tiles render graphics to indicate traffic on the roads in the specified area.
    /// - Parameters:
    ///    - format : Desired format of the response. Possible values are png & pbf.
    ///    - style : The style to be used to render the tile. This parameter is not valid when format is pbf.
    ///    - zoom : Zoom level for the desired tile. For _raster_ tiles, value must be in the range: 0-22 (inclusive). For _vector_ tiles, value must be in the range: 0-22 (inclusive).
    /// Please see [Zoom Levels and Tile Grid](https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid) for details.
    ///    - tileIndex : Parameter group
    ///    - options: A list of options for the operation
    ///    - completionHandler: A completion handler that receives a status code on
    ///     success.
    internal func getTrafficIncidentTile(
        format: TileFormat,
        style: TrafficIncidentTileStyle,
        zoom: Int32,
        tileIndex: TileIndex,
        withOptions options: GetTrafficIncidentTileOptions? = nil,
        completionHandler: @escaping HTTPResultHandler<Void>
    ) {
        let dispatchQueue = options?.dispatchQueue ?? client.commonOptions.dispatchQueue ?? DispatchQueue.main

        // Create request parameters
        let params = RequestParameters(
            (.path, "format", format, .encode), (.query, "style", style, .encode), (.query, "zoom", zoom, .encode),
            (.query, "t", options?.trafficState, .encode),
            (.uri, "$host", client.endpoint.absoluteString, .skipEncoding),
            (.header, "x-ms-client-id", client.clientId, .encode),
            (.query, "api-version", client.options.apiVersion, .encode), (.query, "x", tileIndex.x, .encode),
            (.query, "y", tileIndex.y, .encode), (
                .header,
                "Accept",
                "image/jpeg, image/png, image/pbf, application/vnd.mapbox-vector-tile, application/json",
                .encode
            )
        )

        // Construct request
        let urlTemplate = "/traffic/incident/tile/{format}"
        guard let requestUrl = client.url(host: "{$host}", template: urlTemplate, params: params),
            let request = try? HTTPRequest(method: .get, url: requestUrl, headers: params.headers)
        else {
            client.options.logger.error("Failed to construct HTTP request.")
            return
        }

        // Send request
        let context = PipelineContext.of(keyValues: [
            ContextKey.allowedStatusCodes.rawValue: [200] as AnyObject
        ])
        context.add(cancellationToken: options?.cancellationToken, applying: client.options)
        context.merge(with: options?.context)
        client.request(request, context: context) { result, httpResponse in
            guard let data = httpResponse?.data else {
                let noDataError = AzureError.client("Response data expected but not found.")
                dispatchQueue.async {
                    completionHandler(.failure(noDataError), httpResponse)
                }
                return
            }
            switch result {
            case .success:
                guard let statusCode = httpResponse?.statusCode else {
                    let noStatusCodeError = AzureError.client("Expected a status code in response but didn't find one.")
                    dispatchQueue.async {
                        completionHandler(.failure(noStatusCodeError), httpResponse)
                    }
                    return
                }
                if [
                    200
                ].contains(statusCode) {
                    dispatchQueue.async {
                        completionHandler(
                            .success(()),
                            httpResponse
                        )
                    }
                }
            case .failure:
                do {
                    let decoder = JSONDecoder()
                    let decoded = try decoder.decode(ErrorResponse.self, from: data)
                    dispatchQueue.async {
                        completionHandler(
                            .failure(AzureError.service("An unexpected error occurred.", decoded)),
                            httpResponse
                        )
                    }
                } catch {
                    dispatchQueue.async {
                        completionHandler(.failure(AzureError.client("Decoding error.", error)), httpResponse)
                    }
                }
            }
        }
    }

    /// __Traffic Incident Detail__
    /// **Applies to**: S0 and S1 pricing tiers.
    /// This API provides information on traffic incidents inside a given bounding box, based on the current Traffic  Model ID. The Traffic Model ID is available to grant synchronization of data between calls and API's. The  Traffic Model ID is a key value for determining the currency of traffic incidents. It is updated every minute,  and is valid for two minutes before it times out. It is used in rendering  [incident tiles](https://docs.microsoft.com/en-us/rest/api/maps/traffic/gettrafficincidenttile). It can be  obtained from the [Viewport API](https://docs.microsoft.com/en-us/rest/api/maps/traffic/gettrafficincidentviewport).
    /// - Parameters:
    ///    - format : Desired format of the response. Value can be either _json_ or _xml_.
    ///    - style : The style that will be used to render the tile in Traffic [Incident Tile API](https://docs.microsoft.com/en-us/rest/api/maps/traffic/gettrafficincidenttile).  This will have an effect on the coordinates of traffic incidents in the reply.
    ///    - boundingbox : The `boundingbox` is represented by two value pairs describing it's corners (first pair for lower left corner and second for upper right). The pairs can either be specified using any of the `projection`'s specified below (e.g., _minY,minX,maxY,maxX_) or by two latitude-longitude pairs (e.g., _minLat,minLon,maxLat,maxLon_).<br><br>NOTE: If latitude/longitude pairs are used, then the `projection` parameter must be set to "EPSG4326".
    ///    - boundingZoom : Zoom level for desired tile. 0 to 22 for raster tiles, 0 through 22 for vector tiles
    ///    - trafficmodelid : Number referencing traffic model. This can be obtained from the [Viewport API](https://docs.microsoft.com/en-us/rest/api/maps/traffic/gettrafficincidentviewport). It is updated every minute, and is valid for two minutes before it times out. If the wrong Traffic Model ID is specified, the correct one will be returned by the interface. A value of -1 will always invoke the most recent traffic model
    ///    - options: A list of options for the operation
    ///    - completionHandler: A completion handler that receives a status code on
    ///     success.
    internal func getTrafficIncidentDetail(
        format: ResponseFormat,
        style: IncidentDetailStyle,
        boundingbox: [Double],
        boundingZoom: Int32,
        trafficmodelid: String,
        withOptions options: GetTrafficIncidentDetailOptions? = nil,
        completionHandler: @escaping HTTPResultHandler<TrafficIncidentDetail>
    ) {
        let dispatchQueue = options?.dispatchQueue ?? client.commonOptions.dispatchQueue ?? DispatchQueue.main

        // Create request parameters
        let params = RequestParameters(
            (.path, "format", format, .encode), (.query, "style", style, .encode),
            (.query, "boundingbox", boundingbox.map { "\($0)" }.joined(separator: ","), .encode),
            (.query, "boundingZoom", boundingZoom, .encode), (.query, "trafficmodelid", trafficmodelid, .encode),
            (.query, "language", options?.language, .encode), (.query, "projection", options?.projection, .encode),
            (.query, "geometries", options?.geometries, .encode),
            (.query, "expandCluster", options?.expandCluster, .encode),
            (.query, "originalPosition", options?.originalPosition, .encode),
            (.uri, "$host", client.endpoint.absoluteString, .skipEncoding),
            (.header, "x-ms-client-id", client.clientId, .encode),
            (.query, "api-version", client.options.apiVersion, .encode),
            (.header, "Accept", "application/json", .encode)
        )

        // Construct request
        let urlTemplate = "/traffic/incident/detail/{format}"
        guard let requestUrl = client.url(host: "{$host}", template: urlTemplate, params: params),
            let request = try? HTTPRequest(method: .get, url: requestUrl, headers: params.headers)
        else {
            client.options.logger.error("Failed to construct HTTP request.")
            return
        }

        // Apply client-side validation
        var validationErrors = [String]()
        // Validate boundingZoom
        if boundingZoom > 22 {
            validationErrors.append("boundingZoom: <= 22")
        }
        if boundingZoom < 0 {
            validationErrors.append("boundingZoom: >= 0")
        }
        // Validate boundingbox
        if boundingbox.count > 4 {
            validationErrors.append("boundingbox: maxItems 4")
        }
        if boundingbox.count < 4 {
            validationErrors.append("boundingbox: minItems 4")
        }
        if !validationErrors.isEmpty {
            dispatchQueue.async {
                let error = AzureError.client("Validation Errors: \(validationErrors.joined(separator: ", "))")
                completionHandler(.failure(error), nil)
            }
            return
        }

        // Send request
        let context = PipelineContext.of(keyValues: [
            ContextKey.allowedStatusCodes.rawValue: [200] as AnyObject
        ])
        context.add(cancellationToken: options?.cancellationToken, applying: client.options)
        context.merge(with: options?.context)
        client.request(request, context: context) { result, httpResponse in
            guard let data = httpResponse?.data else {
                let noDataError = AzureError.client("Response data expected but not found.")
                dispatchQueue.async {
                    completionHandler(.failure(noDataError), httpResponse)
                }
                return
            }
            switch result {
            case .success:
                guard let statusCode = httpResponse?.statusCode else {
                    let noStatusCodeError = AzureError.client("Expected a status code in response but didn't find one.")
                    dispatchQueue.async {
                        completionHandler(.failure(noStatusCodeError), httpResponse)
                    }
                    return
                }
                if [
                    200
                ].contains(statusCode) {
                    do {
                        let decoder = JSONDecoder()
                        let decoded = try decoder.decode(TrafficIncidentDetail.self, from: data)
                        dispatchQueue.async {
                            completionHandler(.success(decoded), httpResponse)
                        }
                    } catch {
                        dispatchQueue.async {
                            completionHandler(.failure(AzureError.client("Decoding error.", error)), httpResponse)
                        }
                    }
                }
            case .failure:
                do {
                    let decoder = JSONDecoder()
                    let decoded = try decoder.decode(ErrorResponse.self, from: data)
                    dispatchQueue.async {
                        completionHandler(
                            .failure(AzureError.service("An unexpected error occurred.", decoded)),
                            httpResponse
                        )
                    }
                } catch {
                    dispatchQueue.async {
                        completionHandler(.failure(AzureError.client("Decoding error.", error)), httpResponse)
                    }
                }
            }
        }
    }

    /// __Traffic Incident Viewport__
    /// **Applies to**: S0 and S1 pricing tiers.
    /// This API returns legal and technical information for the viewport described in the request. It should be called  by client applications whenever the viewport changes (for instance, through zooming, panning, going to a  location, or displaying a route). The request should contain the bounding box and zoom level of the viewport  whose information is needed. The return will contain map version information, as well as the current Traffic  Model ID and copyright IDs. The Traffic Model ID returned by the Viewport Description is used by other APIs to  retrieve last traffic information for further processing.
    /// - Parameters:
    ///    - format : Desired format of the response. Value can be either _json_ or _xml_.
    ///    - boundingbox : Bounding box of the map viewport in [EPSG900913](http://docs.openlayers.org/library/spherical_mercator.html) projection. The `boundingbox` is represented by two value pairs describing it's corners (first pair for lower left corner and second for upper right). When this endpoint is called directly, all values should be separated by commas (e.g., _minY,minX,maxY,maxX_). The maximum size of the bounding box that can be passed is dependent on the requested zoom level. The width and height cannot exceed 4092 pixels when rendered on the given zoom level.<br><br>NOTE: Bounding boxes that cross the 180° meridian require special treatment. For such boxes, the eastern _maxX_ value will be negative, and thus less than the _minX_ value west of the 180° meridian. To address that, the value 40075016.6855874 should be added to the true _maxX_ value before it is passed in the request.
    ///    - boundingzoom : Zoom level of the map viewport. Used to determine whether the view can be zoomed in.
    ///    - overviewbox : Bounding box of the overview map in [EPSG900913](http://docs.openlayers.org/library/spherical_mercator.html) projection.<br><br>Used in case the overview box/mini map has different copyright data than the main map. If there is no mini map, the same coordinates as `boundingBox` is used. When this endpoint is called directly, coordinates are passed in as a single string containing four coordinates, separated by commas.
    ///    - overviewzoom : Zoom level of the overview map. If there is no mini map, use the same zoom level as boundingZoom.
    ///    - options: A list of options for the operation
    ///    - completionHandler: A completion handler that receives a status code on
    ///     success.
    internal func getTrafficIncidentViewport(
        format: ResponseFormat,
        boundingbox: [Double],
        boundingzoom: Int32,
        overviewbox: [Double],
        overviewzoom: Int32,
        withOptions options: GetTrafficIncidentViewportOptions? = nil,
        completionHandler: @escaping HTTPResultHandler<TrafficIncidentViewport>
    ) {
        let dispatchQueue = options?.dispatchQueue ?? client.commonOptions.dispatchQueue ?? DispatchQueue.main

        // Create request parameters
        let params = RequestParameters(
            (.path, "format", format, .encode),
            (.query, "boundingbox", boundingbox.map { "\($0)" }.joined(separator: ","), .encode),
            (.query, "boundingzoom", boundingzoom, .encode),
            (.query, "overviewbox", overviewbox.map { "\($0)" }.joined(separator: ","), .encode),
            (.query, "overviewzoom", overviewzoom, .encode), (.query, "copyright", options?.copyright, .encode),
            (.uri, "$host", client.endpoint.absoluteString, .skipEncoding),
            (.header, "x-ms-client-id", client.clientId, .encode),
            (.query, "api-version", client.options.apiVersion, .encode),
            (.header, "Accept", "application/json", .encode)
        )

        // Construct request
        let urlTemplate = "/traffic/incident/viewport/{format}"
        guard let requestUrl = client.url(host: "{$host}", template: urlTemplate, params: params),
            let request = try? HTTPRequest(method: .get, url: requestUrl, headers: params.headers)
        else {
            client.options.logger.error("Failed to construct HTTP request.")
            return
        }

        // Apply client-side validation
        var validationErrors = [String]()
        // Validate boundingbox
        if boundingbox.count > 4 {
            validationErrors.append("boundingbox: maxItems 4")
        }
        if boundingbox.count < 4 {
            validationErrors.append("boundingbox: minItems 4")
        }
        // Validate boundingzoom
        if boundingzoom > 22 {
            validationErrors.append("boundingzoom: <= 22")
        }
        if boundingzoom < 0 {
            validationErrors.append("boundingzoom: >= 0")
        }
        // Validate overviewbox
        if overviewbox.count > 4 {
            validationErrors.append("overviewbox: maxItems 4")
        }
        if overviewbox.count < 4 {
            validationErrors.append("overviewbox: minItems 4")
        }
        // Validate overviewzoom
        if overviewzoom > 22 {
            validationErrors.append("overviewzoom: <= 22")
        }
        if overviewzoom < 0 {
            validationErrors.append("overviewzoom: >= 0")
        }
        if !validationErrors.isEmpty {
            dispatchQueue.async {
                let error = AzureError.client("Validation Errors: \(validationErrors.joined(separator: ", "))")
                completionHandler(.failure(error), nil)
            }
            return
        }

        // Send request
        let context = PipelineContext.of(keyValues: [
            ContextKey.allowedStatusCodes.rawValue: [200] as AnyObject
        ])
        context.add(cancellationToken: options?.cancellationToken, applying: client.options)
        context.merge(with: options?.context)
        client.request(request, context: context) { result, httpResponse in
            guard let data = httpResponse?.data else {
                let noDataError = AzureError.client("Response data expected but not found.")
                dispatchQueue.async {
                    completionHandler(.failure(noDataError), httpResponse)
                }
                return
            }
            switch result {
            case .success:
                guard let statusCode = httpResponse?.statusCode else {
                    let noStatusCodeError = AzureError.client("Expected a status code in response but didn't find one.")
                    dispatchQueue.async {
                        completionHandler(.failure(noStatusCodeError), httpResponse)
                    }
                    return
                }
                if [
                    200
                ].contains(statusCode) {
                    do {
                        let decoder = JSONDecoder()
                        let decoded = try decoder.decode(TrafficIncidentViewport.self, from: data)
                        dispatchQueue.async {
                            completionHandler(.success(decoded), httpResponse)
                        }
                    } catch {
                        dispatchQueue.async {
                            completionHandler(.failure(AzureError.client("Decoding error.", error)), httpResponse)
                        }
                    }
                }
            case .failure:
                do {
                    let decoder = JSONDecoder()
                    let decoded = try decoder.decode(ErrorResponse.self, from: data)
                    dispatchQueue.async {
                        completionHandler(
                            .failure(AzureError.service("An unexpected error occurred.", decoded)),
                            httpResponse
                        )
                    }
                } catch {
                    dispatchQueue.async {
                        completionHandler(.failure(AzureError.client("Decoding error.", error)), httpResponse)
                    }
                }
            }
        }
    }
}
