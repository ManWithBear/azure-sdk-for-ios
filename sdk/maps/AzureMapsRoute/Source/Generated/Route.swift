// --------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for
// license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// --------------------------------------------------------------------------

import AzureCore
import Foundation
// swiftlint:disable superfluous_disable_command
// swiftlint:disable file_length
// swiftlint:disable cyclomatic_complexity
// swiftlint:disable function_body_length
// swiftlint:disable type_body_length

internal final class Route {
    internal let client: RouteClientInternal

    init(client: RouteClientInternal) {
        self.client = client
    }

    /// **Applies to**: S1 pricing tier.
    /// The Matrix Routing service allows calculation of a matrix of route summaries for a set of routes defined by origin and destination locations by using an asynchronous (async) or synchronous (sync) POST request. For every given origin, the service calculates the cost of routing from that origin to every given destination. The set of origins and the set of destinations can be thought of as the column and row headers of a table and each cell in the table contains the costs of routing from the origin to the destination for that cell. As an example, let's say a food delivery company has 20 drivers and they need to find the closest driver to pick up the delivery from the restaurant. To solve this use case, they can call Matrix Route API.
    /// For each route, the travel times and distances are returned. You can use the computed costs to determine which detailed routes to calculate using the Route Directions API.
    /// The maximum size of a matrix for async request is **700** and for sync request it's **100** (the number of origins multiplied by the number of destinations).
    /// ### Submit Synchronous Route Matrix Request
    /// If your scenario requires synchronous requests and the maximum size of the matrix is less than or equal to 100, you might want to make synchronous request. The maximum size of a matrix for this API is **100** (the number of origins multiplied by the number of destinations). With that constraint in mind, examples of possible matrix dimensions are: 10x10, 6x8, 9x8 (it does not need to be square).
    /// ```
    /// POST https://atlas.microsoft.com/route/matrix/sync/json?api-version=1.0&subscription-key={subscription-key}
    /// ```
    /// ### Submit Asynchronous Route Matrix Request
    /// The Asynchronous API is appropriate for processing big volumes of relatively complex routing requests. When you make a request by using async request, by default the service returns a 202 response code along a redirect URL in the Location field of the response header. This URL should be checked periodically until the response data or error information is available. If `waitForResults` parameter in the request is set to true, user will get a 200 response if the request is finished under 120 seconds.
    /// The maximum size of a matrix for this API is **700** (the number of origins multiplied by the number of destinations). With that constraint in mind, examples of possible matrix dimensions are: 50x10, 10x10, 28x25. 10x70 (it does not need to be square).
    /// The asynchronous responses are stored for **14** days. The redirect URL returns a 404 response if used after the expiration period.
    /// ```
    /// POST https://atlas.microsoft.com/route/matrix/json?api-version=1.0&subscription-key={subscription-key}
    /// ```
    /// Here's a typical sequence of asynchronous operations:
    /// 1. Client sends a Route Matrix POST request to Azure Maps
    /// 2. The server will respond with one of the following:
    ///     > HTTP `202 Accepted` -  Route Matrix request has been accepted.
    ///     > HTTP `Error` - There was an error processing your Route Matrix request. This could either be a 400 Bad Request or any other Error status code.
    /// 3. If the Matrix Route request was accepted successfully, the Location header in the response contains the URL to download the results of the request. This status URI looks like the following:
    ///   ```
    ///     GET https://atlas.microsoft.com/route/matrix/{matrixId}?api-version=1.0?subscription-key={subscription-key}
    ///   ```
    /// 4. Client issues a GET request on the download URL obtained in Step 3 to download the results
    /// ### Download Sync Results
    /// When you make a POST request for Route Matrix Sync API, the service returns 200 response code for successful request and a response array. The response body will contain the data and there will be no possibility to retrieve the results later.
    /// ### Download Async Results
    /// When a request issues a `202 Accepted` response, the request is being processed using our async pipeline. You will be given a URL to check the progress of your  async request in the location header of the response. This status URI looks like the following:
    /// ```
    ///   GET https://atlas.microsoft.com/route/matrix/{matrixId}?api-version=1.0?subscription-key={subscription-key}
    /// ```
    /// The URL provided by the location header will return the following responses when a `GET` request is issued.
    ///   > HTTP `202 Accepted` - Matrix request was accepted but is still being processed. Please try again in some time.
    ///   > HTTP `200 OK` - Matrix request successfully processed. The response body contains all of the results.
    /// - Parameters:
    ///    - routeMatrix : The matrix of origin and destination coordinates to compute the route distance, travel time and other summary for each cell of the matrix based on the input parameters. The minimum and the maximum cell count supported are 1 and **700** for async and **100** for sync respectively. For example, it can be 35 origins and 20 destinations or 25 origins and 25 destinations for async API.
    ///    - format : Desired format of the response. Only `json` format is supported.
    ///    - options: A list of options for the operation
    ///    - completionHandler: A completion handler that receives a status code on
    ///     success.
    internal func request(
        routeMatrix: RouteMatrixQuery,
        format: JsonFormat,
        withOptions options: RequestRouteMatrixOptions? = nil,
        completionHandler: @escaping HTTPResultHandler<RouteMatrixResult?>
    ) {
        let dispatchQueue = options?.dispatchQueue ?? client.commonOptions.dispatchQueue ?? DispatchQueue.main

        // Create request parameters
        var params = RequestParameters(
            (.path, "format", format, .encode), (.query, "waitForResults", options?.waitForResults, .encode), (
                .query,
                "computeTravelTimeFor",
                options?.computeTravelTime,
                .encode
            ), (.query, "sectionType", options?.filterSectionType, .encode),
            (.query, "arriveAt", options?.arriveAt, .encode),
            (.query, "departAt", options?.departAt, .encode),
            (.query, "vehicleAxleWeight", options?.vehicleAxleWeight, .encode),
            (.query, "vehicleLength", options?.vehicleLength, .encode),
            (.query, "vehicleHeight", options?.vehicleHeight, .encode),
            (.query, "vehicleWidth", options?.vehicleWidth, .encode),
            (.query, "vehicleMaxSpeed", options?.vehicleMaxSpeed, .encode),
            (.query, "vehicleWeight", options?.vehicleWeight, .encode),
            (.query, "windingness", options?.windingness, .encode),
            (.query, "hilliness", options?.inclineLevel, .encode),
            (.query, "travelMode", options?.travelMode, .encode), (.query, "traffic", options?.useTrafficData, .encode),
            (.query, "routeType", options?.routeType, .encode),
            (.query, "vehicleLoadType", options?.vehicleLoadType, .encode),
            (.uri, "$host", client.endpoint.absoluteString, .skipEncoding),
            (.header, "x-ms-client-id", client.clientId, .encode),
            (.query, "api-version", client.options.apiVersion, .encode),
            (.header, "Content-Type", "application/json", .encode), (.header, "Accept", "application/json", .encode)
        )
        // Explode query parameters
        options?.avoid?.forEach {
            params.add((.query, "avoid", $0, .encode))
        }

        // Construct request
        guard let requestBody = try? JSONEncoder().encode(routeMatrix) else {
            client.options.logger.error("Failed to encode request body as json.")
            return
        }
        let urlTemplate = "/route/matrix/{format}"
        guard let requestUrl = client.url(host: "{$host}", template: urlTemplate, params: params),
            let request = try? HTTPRequest(method: .post, url: requestUrl, headers: params.headers, data: requestBody)
        else {
            client.options.logger.error("Failed to construct HTTP request.")
            return
        }

        // Send request
        let context = PipelineContext.of(keyValues: [
            ContextKey.allowedStatusCodes.rawValue: [200, 202] as AnyObject
        ])
        context.add(cancellationToken: options?.cancellationToken, applying: client.options)
        context.merge(with: options?.context)
        client.request(request, context: context) { result, httpResponse in
            guard let data = httpResponse?.data else {
                let noDataError = AzureError.client("Response data expected but not found.")
                dispatchQueue.async {
                    completionHandler(.failure(noDataError), httpResponse)
                }
                return
            }
            switch result {
            case .success:
                guard let statusCode = httpResponse?.statusCode else {
                    let noStatusCodeError = AzureError.client("Expected a status code in response but didn't find one.")
                    dispatchQueue.async {
                        completionHandler(.failure(noStatusCodeError), httpResponse)
                    }
                    return
                }
                if [
                    200
                ].contains(statusCode) {
                    do {
                        let decoder = JSONDecoder()
                        let decoded = try decoder.decode(RouteMatrixResult.self, from: data)
                        dispatchQueue.async {
                            completionHandler(.success(decoded), httpResponse)
                        }
                    } catch {
                        dispatchQueue.async {
                            completionHandler(.failure(AzureError.client("Decoding error.", error)), httpResponse)
                        }
                    }
                }
                if [
                    202
                ].contains(statusCode) {
                    dispatchQueue.async {
                        completionHandler(
                            .success(nil),
                            httpResponse
                        )
                    }
                }
            case .failure:
                do {
                    let decoder = JSONDecoder()
                    let decoded = try decoder.decode(ErrorResponse.self, from: data)
                    dispatchQueue.async {
                        completionHandler(
                            .failure(AzureError.service("An unexpected error occurred.", decoded)),
                            httpResponse
                        )
                    }
                } catch {
                    dispatchQueue.async {
                        completionHandler(.failure(AzureError.client("Decoding error.", error)), httpResponse)
                    }
                }
            }
        }
    }

    /// If the Matrix Route request was accepted successfully, the Location header in the response contains the URL to download the results of the request. This status URI looks like the following:
    ///   ```
    ///     GET https://atlas.microsoft.com/route/matrix/{matrixId}?api-version=1.0?subscription-key={subscription-key}
    ///   ```
    /// 4. Client issues a GET request on the download URL obtained in Step 3 to download the results
    /// ### Download Sync Results
    /// When you make a POST request for Route Matrix Sync API, the service returns 200 response code for successful request and a response array. The response body will contain the data and there will be no possibility to retrieve the results later.
    /// ### Download Async Results
    /// When a request issues a `202 Accepted` response, the request is being processed using our async pipeline. You will be given a URL to check the progress of your  async request in the location header of the response. This status URI looks like the following:
    /// ```
    ///   GET https://atlas.microsoft.com/route/matrix/{matrixId}?api-version=1.0?subscription-key={subscription-key}
    /// ```
    /// The URL provided by the location header will return the following responses when a `GET` request is issued.
    ///   > HTTP `202 Accepted` - Matrix request was accepted but is still being processed. Please try again in some time.
    ///   > HTTP `200 OK` - Matrix request successfully processed. The response body contains all of the results.
    /// - Parameters:
    ///    - matrixId : Matrix id received after the Matrix Route request was accepted successfully.
    ///    - options: A list of options for the operation
    ///    - completionHandler: A completion handler that receives a status code on
    ///     success.
    internal func getRouteMatrix(
        matrixId: String,
        withOptions options: GetRouteMatrixOptions? = nil,
        completionHandler: @escaping HTTPResultHandler<RouteMatrixResult?>
    ) {
        let dispatchQueue = options?.dispatchQueue ?? client.commonOptions.dispatchQueue ?? DispatchQueue.main

        // Create request parameters
        let params = RequestParameters(
            (.path, "format", matrixId, .encode), (.uri, "$host", client.endpoint.absoluteString, .skipEncoding),
            (.header, "x-ms-client-id", client.clientId, .encode),
            (.query, "api-version", client.options.apiVersion, .encode),
            (.header, "Accept", "application/json", .encode)
        )

        // Construct request
        let urlTemplate = "/route/matrix/{format}"
        guard let requestUrl = client.url(host: "{$host}", template: urlTemplate, params: params),
            let request = try? HTTPRequest(method: .get, url: requestUrl, headers: params.headers)
        else {
            client.options.logger.error("Failed to construct HTTP request.")
            return
        }

        // Send request
        let context = PipelineContext.of(keyValues: [
            ContextKey.allowedStatusCodes.rawValue: [200, 202] as AnyObject
        ])
        context.add(cancellationToken: options?.cancellationToken, applying: client.options)
        context.merge(with: options?.context)
        client.request(request, context: context) { result, httpResponse in
            guard let data = httpResponse?.data else {
                let noDataError = AzureError.client("Response data expected but not found.")
                dispatchQueue.async {
                    completionHandler(.failure(noDataError), httpResponse)
                }
                return
            }
            switch result {
            case .success:
                guard let statusCode = httpResponse?.statusCode else {
                    let noStatusCodeError = AzureError.client("Expected a status code in response but didn't find one.")
                    dispatchQueue.async {
                        completionHandler(.failure(noStatusCodeError), httpResponse)
                    }
                    return
                }
                if [
                    200
                ].contains(statusCode) {
                    do {
                        let decoder = JSONDecoder()
                        let decoded = try decoder.decode(RouteMatrixResult.self, from: data)
                        dispatchQueue.async {
                            completionHandler(.success(decoded), httpResponse)
                        }
                    } catch {
                        dispatchQueue.async {
                            completionHandler(.failure(AzureError.client("Decoding error.", error)), httpResponse)
                        }
                    }
                }
                if [
                    202
                ].contains(statusCode) {
                    dispatchQueue.async {
                        completionHandler(
                            .success(nil),
                            httpResponse
                        )
                    }
                }
            case .failure:
                do {
                    let decoder = JSONDecoder()
                    let decoded = try decoder.decode(ErrorResponse.self, from: data)
                    dispatchQueue.async {
                        completionHandler(
                            .failure(AzureError.service("An unexpected error occurred.", decoded)),
                            httpResponse
                        )
                    }
                } catch {
                    dispatchQueue.async {
                        completionHandler(.failure(AzureError.client("Decoding error.", error)), httpResponse)
                    }
                }
            }
        }
    }

    /// **Applies to**: S1 pricing tier.
    /// The Matrix Routing service allows calculation of a matrix of route summaries for a set of routes defined by origin and destination locations by using an asynchronous (async) or synchronous (sync) POST request. For every given origin, the service calculates the cost of routing from that origin to every given destination. The set of origins and the set of destinations can be thought of as the column and row headers of a table and each cell in the table contains the costs of routing from the origin to the destination for that cell. As an example, let's say a food delivery company has 20 drivers and they need to find the closest driver to pick up the delivery from the restaurant. To solve this use case, they can call Matrix Route API.
    /// For each route, the travel times and distances are returned. You can use the computed costs to determine which detailed routes to calculate using the Route Directions API.
    /// The maximum size of a matrix for async request is **700** and for sync request it's **100** (the number of origins multiplied by the number of destinations).
    /// ### Submit Synchronous Route Matrix Request
    /// If your scenario requires synchronous requests and the maximum size of the matrix is less than or equal to 100, you might want to make synchronous request. The maximum size of a matrix for this API is **100** (the number of origins multiplied by the number of destinations). With that constraint in mind, examples of possible matrix dimensions are: 10x10, 6x8, 9x8 (it does not need to be square).
    /// ```
    /// POST https://atlas.microsoft.com/route/matrix/sync/json?api-version=1.0&subscription-key={subscription-key}
    /// ```
    /// ### Submit Asynchronous Route Matrix Request
    /// The Asynchronous API is appropriate for processing big volumes of relatively complex routing requests. When you make a request by using async request, by default the service returns a 202 response code along a redirect URL in the Location field of the response header. This URL should be checked periodically until the response data or error information is available. If `waitForResults` parameter in the request is set to true, user will get a 200 response if the request is finished under 120 seconds.
    /// The maximum size of a matrix for this API is **700** (the number of origins multiplied by the number of destinations). With that constraint in mind, examples of possible matrix dimensions are: 50x10, 10x10, 28x25. 10x70 (it does not need to be square).
    /// The asynchronous responses are stored for **14** days. The redirect URL returns a 404 response if used after the expiration period.
    /// ```
    /// POST https://atlas.microsoft.com/route/matrix/json?api-version=1.0&subscription-key={subscription-key}
    /// ```
    /// Here's a typical sequence of asynchronous operations:
    /// 1. Client sends a Route Matrix POST request to Azure Maps
    /// 2. The server will respond with one of the following:
    ///     > HTTP `202 Accepted` -  Route Matrix request has been accepted.
    ///     > HTTP `Error` - There was an error processing your Route Matrix request. This could either be a 400 Bad Request or any other Error status code.
    /// 3. If the Matrix Route request was accepted successfully, the Location header in the response contains the URL to download the results of the request. This status URI looks like the following:
    ///   ```
    ///     GET https://atlas.microsoft.com/route/matrix/{matrixId}?api-version=1.0?subscription-key={subscription-key}
    ///   ```
    /// 4. Client issues a GET request on the download URL obtained in Step 3 to download the results
    /// ### Download Sync Results
    /// When you make a POST request for Route Matrix Sync API, the service returns 200 response code for successful request and a response array. The response body will contain the data and there will be no possibility to retrieve the results later.
    /// ### Download Async Results
    /// When a request issues a `202 Accepted` response, the request is being processed using our async pipeline. You will be given a URL to check the progress of your  async request in the location header of the response. This status URI looks like the following:
    /// ```
    ///   GET https://atlas.microsoft.com/route/matrix/{matrixId}?api-version=1.0?subscription-key={subscription-key}
    /// ```
    /// The URL provided by the location header will return the following responses when a `GET` request is issued.
    ///   > HTTP `202 Accepted` - Matrix request was accepted but is still being processed. Please try again in some time.
    ///   > HTTP `200 OK` - Matrix request successfully processed. The response body contains all of the results.
    /// - Parameters:
    ///    - routeMatrixSync : The matrix of origin and destination coordinates to compute the route distance, travel time and other summary for each cell of the matrix based on the input parameters. The minimum and the maximum cell count supported are 1 and **700** for async and **100** for sync respectively. For example, it can be 35 origins and 20 destinations or 25 origins and 25 destinations for async API.
    ///    - format : Desired format of the response. Only `json` format is supported.
    ///    - options: A list of options for the operation
    ///    - completionHandler: A completion handler that receives a status code on
    ///     success.
    internal func request(
        routeMatrixSync: RouteMatrixQuery,
        format: JsonFormat,
        withOptions options: RequestRouteMatrixSyncOptions? = nil,
        completionHandler: @escaping HTTPResultHandler<RouteMatrixResult>
    ) {
        let dispatchQueue = options?.dispatchQueue ?? client.commonOptions.dispatchQueue ?? DispatchQueue.main

        // Create request parameters
        var params = RequestParameters(
            (.path, "format", format, .encode), (.query, "waitForResults", options?.waitForResults, .encode), (
                .query,
                "computeTravelTimeFor",
                options?.computeTravelTime,
                .encode
            ), (.query, "sectionType", options?.filterSectionType, .encode),
            (.query, "arriveAt", options?.arriveAt, .encode),
            (.query, "departAt", options?.departAt, .encode),
            (.query, "vehicleAxleWeight", options?.vehicleAxleWeight, .encode),
            (.query, "vehicleLength", options?.vehicleLength, .encode),
            (.query, "vehicleHeight", options?.vehicleHeight, .encode),
            (.query, "vehicleWidth", options?.vehicleWidth, .encode),
            (.query, "vehicleMaxSpeed", options?.vehicleMaxSpeed, .encode),
            (.query, "vehicleWeight", options?.vehicleWeight, .encode),
            (.query, "windingness", options?.windingness, .encode),
            (.query, "hilliness", options?.inclineLevel, .encode),
            (.query, "travelMode", options?.travelMode, .encode), (.query, "traffic", options?.useTrafficData, .encode),
            (.query, "routeType", options?.routeType, .encode),
            (.query, "vehicleLoadType", options?.vehicleLoadType, .encode),
            (.uri, "$host", client.endpoint.absoluteString, .skipEncoding),
            (.header, "x-ms-client-id", client.clientId, .encode),
            (.query, "api-version", client.options.apiVersion, .encode),
            (.header, "Content-Type", "application/json", .encode), (.header, "Accept", "application/json", .encode)
        )
        // Explode query parameters
        options?.avoid?.forEach {
            params.add((.query, "avoid", $0, .encode))
        }

        // Construct request
        guard let requestBody = try? JSONEncoder().encode(routeMatrixSync) else {
            client.options.logger.error("Failed to encode request body as json.")
            return
        }
        let urlTemplate = "/route/matrix/sync/{format}"
        guard let requestUrl = client.url(host: "{$host}", template: urlTemplate, params: params),
            let request = try? HTTPRequest(method: .post, url: requestUrl, headers: params.headers, data: requestBody)
        else {
            client.options.logger.error("Failed to construct HTTP request.")
            return
        }

        // Send request
        let context = PipelineContext.of(keyValues: [
            ContextKey.allowedStatusCodes.rawValue: [200, 408] as AnyObject
        ])
        context.add(cancellationToken: options?.cancellationToken, applying: client.options)
        context.merge(with: options?.context)
        client.request(request, context: context) { result, httpResponse in
            guard let data = httpResponse?.data else {
                let noDataError = AzureError.client("Response data expected but not found.")
                dispatchQueue.async {
                    completionHandler(.failure(noDataError), httpResponse)
                }
                return
            }
            switch result {
            case .success:
                guard let statusCode = httpResponse?.statusCode else {
                    let noStatusCodeError = AzureError.client("Expected a status code in response but didn't find one.")
                    dispatchQueue.async {
                        completionHandler(.failure(noStatusCodeError), httpResponse)
                    }
                    return
                }
                if [
                    200
                ].contains(statusCode) {
                    do {
                        let decoder = JSONDecoder()
                        let decoded = try decoder.decode(RouteMatrixResult.self, from: data)
                        dispatchQueue.async {
                            completionHandler(.success(decoded), httpResponse)
                        }
                    } catch {
                        dispatchQueue.async {
                            completionHandler(.failure(AzureError.client("Decoding error.", error)), httpResponse)
                        }
                    }
                }
                if [408].contains(statusCode) {
                    do {
                        let decoder = JSONDecoder()
                        let decoded = try decoder.decode(ErrorResponse.self, from: data)
                        dispatchQueue.async {
                            completionHandler(
                                .failure(AzureError.service(
                                    "Timeout: The request took longer to finish than the maximum amount of time defined in the api.",
                                    decoded
                                )),
                                httpResponse
                            )
                        }
                    } catch {
                        dispatchQueue.async {
                            completionHandler(.failure(AzureError.client("Decoding error.", error)), httpResponse)
                        }
                    }
                }
            case .failure:
                do {
                    let decoder = JSONDecoder()
                    let decoded = try decoder.decode(ErrorResponse.self, from: data)
                    dispatchQueue.async {
                        completionHandler(
                            .failure(AzureError.service("An unexpected error occurred.", decoded)),
                            httpResponse
                        )
                    }
                } catch {
                    dispatchQueue.async {
                        completionHandler(.failure(AzureError.client("Decoding error.", error)), httpResponse)
                    }
                }
            }
        }
    }

    /// **Applies to**: S0 and S1 pricing tiers.
    /// Returns  a route between an origin and a destination, passing through waypoints if they are specified. The route will take into account factors such as current traffic and the typical road speeds on the requested day of the week and time of day.
    /// Information returned includes the distance, estimated travel time, and a representation of the route geometry. Additional routing information such as optimized waypoint order or turn by turn instructions is also available, depending on the options selected.
    /// Routing service provides a set of parameters for a detailed description of vehicle-specific Consumption Model. Please check [Consumption Model](https://docs.microsoft.com/azure/azure-maps/consumption-model) for detailed explanation of the concepts and parameters involved.
    /// - Parameters:
    ///    - format : Desired format of the response. Value can be either _json_ or _xml_.
    ///    - routePoints : The Coordinates through which the route is calculated, delimited by a colon.  A minimum of two coordinates is required.  The first one is the origin and the last is the destination of the route. Optional coordinates in-between act as WayPoints in the route.  You can pass up to 150 WayPoints.
    ///    - options: A list of options for the operation
    ///    - completionHandler: A completion handler that receives a status code on
    ///     success.
    internal func getRouteDirections(
        format: ResponseFormat,
        routePoints: String,
        withOptions options: GetRouteDirectionsOptions? = nil,
        completionHandler: @escaping HTTPResultHandler<RouteDirections>
    ) {
        let dispatchQueue = options?.dispatchQueue ?? client.commonOptions.dispatchQueue ?? DispatchQueue.main

        // Create request parameters
        var params = RequestParameters(
            (.path, "format", format, .encode), (.query, "query", routePoints, .encode),
            (.query, "maxAlternatives", options?.maxAlternatives, .encode),
            (.query, "alternativeType", options?.alternativeType, .encode), (
                .query,
                "minDeviationDistance",
                options?.minDeviationDistance,
                .encode
            ), (.query, "arriveAt", options?.arriveAt, .encode), (.query, "departAt", options?.departAt, .encode),
            (.query, "minDeviationTime", options?.minDeviationTime, .encode), (
                .query,
                "instructionsType",
                options?.instructionsType,
                .encode
            ), (.query, "language", options?.language, .encode),
            (.query, "computeBestOrder", options?.computeBestWaypointOrder, .encode), (
                .query,
                "routeRepresentation",
                options?.routeRepresentationForBestOrder,
                .encode
            ), (.query, "computeTravelTimeFor", options?.computeTravelTime, .encode), (
                .query,
                "vehicleHeading",
                options?.vehicleHeading,
                .encode
            ), (.query, "report", options?.report, .encode),
            (.query, "sectionType", options?.filterSectionType, .encode),
            (.query, "vehicleAxleWeight", options?.vehicleAxleWeight, .encode),
            (.query, "vehicleWidth", options?.vehicleWidth, .encode),
            (.query, "vehicleHeight", options?.vehicleHeight, .encode),
            (.query, "vehicleLength", options?.vehicleLength, .encode),
            (.query, "vehicleMaxSpeed", options?.vehicleMaxSpeed, .encode),
            (.query, "vehicleWeight", options?.vehicleWeight, .encode),
            (.query, "vehicleCommercial", options?.isCommercialVehicle, .encode),
            (.query, "windingness", options?.windingness, .encode),
            (.query, "hilliness", options?.inclineLevel, .encode),
            (.query, "travelMode", options?.travelMode, .encode), (.query, "traffic", options?.useTrafficData, .encode),
            (.query, "routeType", options?.routeType, .encode),
            (.query, "vehicleLoadType", options?.vehicleLoadType, .encode), (
                .query,
                "vehicleEngineType",
                options?.vehicleEngineType,
                .encode
            ), (
                .query,
                "constantSpeedConsumptionInLitersPerHundredkm",
                options?.constantSpeedConsumptionInLitersPerHundredKm,
                .encode
            ), (.query, "currentFuelInLiters", options?.currentFuelInLiters, .encode), (
                .query,
                "auxiliaryPowerInLitersPerHour",
                options?.auxiliaryPowerInLitersPerHour,
                .encode
            ), (.query, "fuelEnergyDensityInMJoulesPerLiter", options?.fuelEnergyDensityInMegajoulesPerLiter, .encode),
            (
                .query,
                "accelerationEfficiency",
                options?.accelerationEfficiency,
                .encode
            ), (.query, "decelerationEfficiency", options?.decelerationEfficiency, .encode), (
                .query,
                "uphillEfficiency",
                options?.uphillEfficiency,
                .encode
            ), (.query, "downhillEfficiency", options?.downhillEfficiency, .encode), (
                .query,
                "constantSpeedConsumptionInkWhPerHundredkm",
                options?.constantSpeedConsumptionInKwHPerHundredKm,
                .encode
            ), (.query, "currentChargeInkWh", options?.currentChargeInKwH, .encode), (
                .query,
                "maxChargeInkWh",
                options?.maxChargeInKwH,
                .encode
            ), (.query, "auxiliaryPowerInkW", options?.auxiliaryPowerInKw, .encode), (
                .uri,
                "$host",
                client.endpoint.absoluteString,
                .skipEncoding
            ), (.header, "x-ms-client-id", client.clientId, .encode),
            (.query, "api-version", client.options.apiVersion, .encode),
            (.header, "Accept", "application/json", .encode)
        )
        // Explode query parameters
        options?.avoid?.forEach {
            params.add((.query, "avoid", $0, .encode))
        }

        // Construct request
        let urlTemplate = "/route/directions/{format}"
        guard let requestUrl = client.url(host: "{$host}", template: urlTemplate, params: params),
            let request = try? HTTPRequest(method: .get, url: requestUrl, headers: params.headers)
        else {
            client.options.logger.error("Failed to construct HTTP request.")
            return
        }

        // Apply client-side validation
        var validationErrors = [String]()
        // Validate accelerationEfficiency
        if let accelerationEfficiency = options?.accelerationEfficiency, accelerationEfficiency > 1 {
            validationErrors.append("accelerationEfficiency: <= 1")
        }
        if let accelerationEfficiency = options?.accelerationEfficiency, accelerationEfficiency < 0 {
            validationErrors.append("accelerationEfficiency: >= 0")
        }
        // Validate decelerationEfficiency
        if let decelerationEfficiency = options?.decelerationEfficiency, decelerationEfficiency > 1 {
            validationErrors.append("decelerationEfficiency: <= 1")
        }
        if let decelerationEfficiency = options?.decelerationEfficiency, decelerationEfficiency < 0 {
            validationErrors.append("decelerationEfficiency: >= 0")
        }
        // Validate downhillEfficiency
        if let downhillEfficiency = options?.downhillEfficiency, downhillEfficiency > 1 {
            validationErrors.append("downhillEfficiency: <= 1")
        }
        if let downhillEfficiency = options?.downhillEfficiency, downhillEfficiency < 0 {
            validationErrors.append("downhillEfficiency: >= 0")
        }
        // Validate maxAlternatives
        if let maxAlternatives = options?.maxAlternatives, maxAlternatives > 5 {
            validationErrors.append("maxAlternatives: <= 5")
        }
        if let maxAlternatives = options?.maxAlternatives, maxAlternatives < 0 {
            validationErrors.append("maxAlternatives: >= 0")
        }
        // Validate uphillEfficiency
        if let uphillEfficiency = options?.uphillEfficiency, uphillEfficiency > 1 {
            validationErrors.append("uphillEfficiency: <= 1")
        }
        if let uphillEfficiency = options?.uphillEfficiency, uphillEfficiency < 0 {
            validationErrors.append("uphillEfficiency: >= 0")
        }
        // Validate vehicleHeading
        if let vehicleHeading = options?.vehicleHeading, vehicleHeading > 359 {
            validationErrors.append("vehicleHeading: <= 359")
        }
        if let vehicleHeading = options?.vehicleHeading, vehicleHeading < 0 {
            validationErrors.append("vehicleHeading: >= 0")
        }
        if !validationErrors.isEmpty {
            dispatchQueue.async {
                let error = AzureError.client("Validation Errors: \(validationErrors.joined(separator: ", "))")
                completionHandler(.failure(error), nil)
            }
            return
        }

        // Send request
        let context = PipelineContext.of(keyValues: [
            ContextKey.allowedStatusCodes.rawValue: [200] as AnyObject
        ])
        context.add(cancellationToken: options?.cancellationToken, applying: client.options)
        context.merge(with: options?.context)
        client.request(request, context: context) { result, httpResponse in
            guard let data = httpResponse?.data else {
                let noDataError = AzureError.client("Response data expected but not found.")
                dispatchQueue.async {
                    completionHandler(.failure(noDataError), httpResponse)
                }
                return
            }
            switch result {
            case .success:
                guard let statusCode = httpResponse?.statusCode else {
                    let noStatusCodeError = AzureError.client("Expected a status code in response but didn't find one.")
                    dispatchQueue.async {
                        completionHandler(.failure(noStatusCodeError), httpResponse)
                    }
                    return
                }
                if [
                    200
                ].contains(statusCode) {
                    do {
                        let decoder = JSONDecoder()
                        let decoded = try decoder.decode(RouteDirections.self, from: data)
                        dispatchQueue.async {
                            completionHandler(.success(decoded), httpResponse)
                        }
                    } catch {
                        dispatchQueue.async {
                            completionHandler(.failure(AzureError.client("Decoding error.", error)), httpResponse)
                        }
                    }
                }
            case .failure:
                do {
                    let decoder = JSONDecoder()
                    let decoded = try decoder.decode(ErrorResponse.self, from: data)
                    dispatchQueue.async {
                        completionHandler(
                            .failure(AzureError.service("An unexpected error occurred.", decoded)),
                            httpResponse
                        )
                    }
                } catch {
                    dispatchQueue.async {
                        completionHandler(.failure(AzureError.client("Decoding error.", error)), httpResponse)
                    }
                }
            }
        }
    }

    /// **Applies to**: S0 and S1 pricing tiers.
    /// Returns  a route between an origin and a destination, passing through waypoints if they are specified. The route will take into account factors such as current traffic and the typical road speeds on the requested day of the week and time of day.
    /// Information returned includes the distance, estimated travel time, and a representation of the route geometry. Additional routing information such as optimized waypoint order or turn by turn instructions is also available, depending on the options selected.
    /// Routing service provides a set of parameters for a detailed description of a vehicle-specific Consumption Model. Please check [Consumption Model](https://docs.microsoft.com/azure/azure-maps/consumption-model) for detailed explanation of the concepts and parameters involved.
    /// - Parameters:
    ///    - routeDirectionsWithAdditionalParameters : Used for reconstructing a route and for calculating zero or more alternative routes to this reference route.  The provided sequence of coordinates is used as input for route reconstruction. The alternative routes  are calculated between the origin and destination points specified in the base path parameter locations.  If both minDeviationDistance and minDeviationTime are set to zero, then these origin and destination points  are expected to be at (or very near) the beginning and end of the reference route, respectively. Intermediate  locations (waypoints) are not supported when using supportingPoints.
    /// /// Setting at least one of minDeviationDistance or minDeviationTime to a value greater than zero has the  following consequences:
    /// /// *  The origin point of the calculateRoute request must be on (or very near) the input reference route. If  this is not the case, an error is returned. However, the origin point does not need to be at the beginning of  the input reference route (it can be thought of as the current vehicle position on the reference route).
    /// /// *  The reference route, returned as the first route in the calculateRoute response, will start at the origin  point specified in the calculateRoute request. The initial part of the input reference route up until the  origin point will be excluded from the response.
    /// /// *  The values of minDeviationDistance and minDeviationTime determine how far alternative routes will be  guaranteed to follow the reference route from the origin point onwards.
    /// /// *  The route must use departAt.
    /// /// *  The vehicleHeading is ignored.
    ///    - format : Desired format of the response. Value can be either _json_ or _xml_.
    ///    - routePoints : The Coordinates through which the route is calculated, delimited by a colon.  A minimum of two coordinates is required.  The first one is the origin and the last is the destination of the route. Optional coordinates in-between act as WayPoints in the route.  You can pass up to 150 WayPoints.
    ///    - options: A list of options for the operation
    ///    - completionHandler: A completion handler that receives a status code on
    ///     success.
    internal func get(
        routeDirectionsWithAdditionalParameters: RouteDirectionParameters,
        format: ResponseFormat,
        routePoints: String,
        withOptions options: GetRouteDirectionsWithAdditionalParametersOptions? = nil,
        completionHandler: @escaping HTTPResultHandler<RouteDirections>
    ) {
        let dispatchQueue = options?.dispatchQueue ?? client.commonOptions.dispatchQueue ?? DispatchQueue.main

        // Create request parameters
        var params = RequestParameters(
            (.path, "format", format, .encode), (.query, "query", routePoints, .encode),
            (.query, "maxAlternatives", options?.maxAlternatives, .encode),
            (.query, "alternativeType", options?.alternativeType, .encode), (
                .query,
                "minDeviationDistance",
                options?.minDeviationDistance,
                .encode
            ), (.query, "minDeviationTime", options?.minDeviationTime, .encode), (
                .query,
                "instructionsType",
                options?.instructionsType,
                .encode
            ), (.query, "language", options?.language, .encode),
            (.query, "computeBestOrder", options?.computeBestWaypointOrder, .encode), (
                .query,
                "routeRepresentation",
                options?.routeRepresentationForBestOrder,
                .encode
            ), (.query, "computeTravelTimeFor", options?.computeTravelTime, .encode), (
                .query,
                "vehicleHeading",
                options?.vehicleHeading,
                .encode
            ), (.query, "report", options?.report, .encode),
            (.query, "sectionType", options?.filterSectionType, .encode),
            (.query, "arriveAt", options?.arriveAt, .encode), (.query, "departAt", options?.departAt, .encode),
            (.query, "vehicleAxleWeight", options?.vehicleAxleWeight, .encode),
            (.query, "vehicleLength", options?.vehicleLength, .encode),
            (.query, "vehicleHeight", options?.vehicleHeight, .encode),
            (.query, "vehicleWidth", options?.vehicleWidth, .encode),
            (.query, "vehicleMaxSpeed", options?.vehicleMaxSpeed, .encode),
            (.query, "vehicleWeight", options?.vehicleWeight, .encode),
            (.query, "vehicleCommercial", options?.isCommercialVehicle, .encode),
            (.query, "windingness", options?.windingness, .encode),
            (.query, "hilliness", options?.inclineLevel, .encode),
            (.query, "travelMode", options?.travelMode, .encode), (.query, "traffic", options?.useTrafficData, .encode),
            (.query, "routeType", options?.routeType, .encode),
            (.query, "vehicleLoadType", options?.vehicleLoadType, .encode), (
                .query,
                "vehicleEngineType",
                options?.vehicleEngineType,
                .encode
            ), (
                .query,
                "constantSpeedConsumptionInLitersPerHundredkm",
                options?.constantSpeedConsumptionInLitersPerHundredKm,
                .encode
            ), (.query, "currentFuelInLiters", options?.currentFuelInLiters, .encode), (
                .query,
                "auxiliaryPowerInLitersPerHour",
                options?.auxiliaryPowerInLitersPerHour,
                .encode
            ), (.query, "fuelEnergyDensityInMJoulesPerLiter", options?.fuelEnergyDensityInMegajoulesPerLiter, .encode),
            (
                .query,
                "accelerationEfficiency",
                options?.accelerationEfficiency,
                .encode
            ), (.query, "decelerationEfficiency", options?.decelerationEfficiency, .encode), (
                .query,
                "uphillEfficiency",
                options?.uphillEfficiency,
                .encode
            ), (.query, "downhillEfficiency", options?.downhillEfficiency, .encode), (
                .query,
                "constantSpeedConsumptionInkWhPerHundredkm",
                options?.constantSpeedConsumptionInKwHPerHundredKm,
                .encode
            ), (.query, "currentChargeInkWh", options?.currentChargeInKwH, .encode), (
                .query,
                "maxChargeInkWh",
                options?.maxChargeInKwH,
                .encode
            ), (.query, "auxiliaryPowerInkW", options?.auxiliaryPowerInKw, .encode), (
                .uri,
                "$host",
                client.endpoint.absoluteString,
                .skipEncoding
            ), (.header, "x-ms-client-id", client.clientId, .encode),
            (.query, "api-version", client.options.apiVersion, .encode),
            (.header, "Content-Type", "application/json", .encode), (.header, "Accept", "application/json", .encode)
        )
        // Explode query parameters
        options?.avoid?.forEach {
            params.add((.query, "avoid", $0, .encode))
        }

        // Construct request
        guard let requestBody = try? JSONEncoder().encode(routeDirectionsWithAdditionalParameters) else {
            client.options.logger.error("Failed to encode request body as json.")
            return
        }
        let urlTemplate = "/route/directions/{format}"
        guard let requestUrl = client.url(host: "{$host}", template: urlTemplate, params: params),
            let request = try? HTTPRequest(method: .post, url: requestUrl, headers: params.headers, data: requestBody)
        else {
            client.options.logger.error("Failed to construct HTTP request.")
            return
        }

        // Apply client-side validation
        var validationErrors = [String]()
        // Validate accelerationEfficiency
        if let accelerationEfficiency = options?.accelerationEfficiency, accelerationEfficiency > 1 {
            validationErrors.append("accelerationEfficiency: <= 1")
        }
        if let accelerationEfficiency = options?.accelerationEfficiency, accelerationEfficiency < 0 {
            validationErrors.append("accelerationEfficiency: >= 0")
        }
        // Validate decelerationEfficiency
        if let decelerationEfficiency = options?.decelerationEfficiency, decelerationEfficiency > 1 {
            validationErrors.append("decelerationEfficiency: <= 1")
        }
        if let decelerationEfficiency = options?.decelerationEfficiency, decelerationEfficiency < 0 {
            validationErrors.append("decelerationEfficiency: >= 0")
        }
        // Validate downhillEfficiency
        if let downhillEfficiency = options?.downhillEfficiency, downhillEfficiency > 1 {
            validationErrors.append("downhillEfficiency: <= 1")
        }
        if let downhillEfficiency = options?.downhillEfficiency, downhillEfficiency < 0 {
            validationErrors.append("downhillEfficiency: >= 0")
        }
        // Validate maxAlternatives
        if let maxAlternatives = options?.maxAlternatives, maxAlternatives > 5 {
            validationErrors.append("maxAlternatives: <= 5")
        }
        if let maxAlternatives = options?.maxAlternatives, maxAlternatives < 0 {
            validationErrors.append("maxAlternatives: >= 0")
        }
        // Validate uphillEfficiency
        if let uphillEfficiency = options?.uphillEfficiency, uphillEfficiency > 1 {
            validationErrors.append("uphillEfficiency: <= 1")
        }
        if let uphillEfficiency = options?.uphillEfficiency, uphillEfficiency < 0 {
            validationErrors.append("uphillEfficiency: >= 0")
        }
        // Validate vehicleHeading
        if let vehicleHeading = options?.vehicleHeading, vehicleHeading > 359 {
            validationErrors.append("vehicleHeading: <= 359")
        }
        if let vehicleHeading = options?.vehicleHeading, vehicleHeading < 0 {
            validationErrors.append("vehicleHeading: >= 0")
        }
        if !validationErrors.isEmpty {
            dispatchQueue.async {
                let error = AzureError.client("Validation Errors: \(validationErrors.joined(separator: ", "))")
                completionHandler(.failure(error), nil)
            }
            return
        }

        // Send request
        let context = PipelineContext.of(keyValues: [
            ContextKey.allowedStatusCodes.rawValue: [200] as AnyObject
        ])
        context.add(cancellationToken: options?.cancellationToken, applying: client.options)
        context.merge(with: options?.context)
        client.request(request, context: context) { result, httpResponse in
            guard let data = httpResponse?.data else {
                let noDataError = AzureError.client("Response data expected but not found.")
                dispatchQueue.async {
                    completionHandler(.failure(noDataError), httpResponse)
                }
                return
            }
            switch result {
            case .success:
                guard let statusCode = httpResponse?.statusCode else {
                    let noStatusCodeError = AzureError.client("Expected a status code in response but didn't find one.")
                    dispatchQueue.async {
                        completionHandler(.failure(noStatusCodeError), httpResponse)
                    }
                    return
                }
                if [
                    200
                ].contains(statusCode) {
                    do {
                        let decoder = JSONDecoder()
                        let decoded = try decoder.decode(RouteDirections.self, from: data)
                        dispatchQueue.async {
                            completionHandler(.success(decoded), httpResponse)
                        }
                    } catch {
                        dispatchQueue.async {
                            completionHandler(.failure(AzureError.client("Decoding error.", error)), httpResponse)
                        }
                    }
                }
            case .failure:
                do {
                    let decoder = JSONDecoder()
                    let decoded = try decoder.decode(ErrorResponse.self, from: data)
                    dispatchQueue.async {
                        completionHandler(
                            .failure(AzureError.service("An unexpected error occurred.", decoded)),
                            httpResponse
                        )
                    }
                } catch {
                    dispatchQueue.async {
                        completionHandler(.failure(AzureError.client("Decoding error.", error)), httpResponse)
                    }
                }
            }
        }
    }

    /// __Route Range (Isochrone) API__
    /// **Applies to**: S1 pricing tier.
    /// This service will calculate a set of locations that can be reached from the origin point based on fuel, energy,  time or distance budget that is specified. A polygon boundary (or Isochrone) is returned in a counterclockwise  orientation as well as the precise polygon center which was the result of the origin point.
    /// The returned polygon can be used for further processing such as  [Search Inside Geometry](https://docs.microsoft.com/rest/api/maps/search/postsearchinsidegeometry) to  search for POIs within the provided Isochrone.
    /// - Parameters:
    ///    - format : Desired format of the response. Value can be either _json_ or _xml_.
    ///    - query : The Coordinate from which the range calculation should start.
    ///    - options: A list of options for the operation
    ///    - completionHandler: A completion handler that receives a status code on
    ///     success.
    internal func getRouteRange(
        format: ResponseFormat,
        query: [Double],
        withOptions options: GetRouteRangeOptions? = nil,
        completionHandler: @escaping HTTPResultHandler<RouteRangeResult>
    ) {
        let dispatchQueue = options?.dispatchQueue ?? client.commonOptions.dispatchQueue ?? DispatchQueue.main

        // Create request parameters
        var params = RequestParameters(
            (.path, "format", format, .encode), (.query, "query", query.map { "\($0)" }.joined(separator: ","), .encode),
            (.query, "fuelBudgetInLiters", options?.fuelBudgetInLiters, .encode), (
                .query,
                "energyBudgetInkWh",
                options?.energyBudgetInKwH,
                .encode
            ), (.query, "timeBudgetInSec", options?.timeBudgetInSec, .encode), (
                .query,
                "distanceBudgetInMeters",
                options?.distanceBudgetInMeters,
                .encode
            ), (.query, "departAt", options?.departAt, .encode), (.query, "routeType", options?.routeType, .encode),
            (.query, "traffic", options?.useTrafficData, .encode), (.query, "travelMode", options?.travelMode, .encode),
            (.query, "hilliness", options?.inclineLevel, .encode),
            (.query, "windingness", options?.windingness, .encode),
            (.query, "vehicleAxleWeight", options?.vehicleAxleWeight, .encode),
            (.query, "vehicleWidth", options?.vehicleWidth, .encode),
            (.query, "vehicleHeight", options?.vehicleHeight, .encode),
            (.query, "vehicleLength", options?.vehicleLength, .encode),
            (.query, "vehicleMaxSpeed", options?.vehicleMaxSpeed, .encode),
            (.query, "vehicleWeight", options?.vehicleWeight, .encode),
            (.query, "vehicleCommercial", options?.isCommercialVehicle, .encode), (
                .query,
                "vehicleLoadType",
                options?.vehicleLoadType,
                .encode
            ), (.query, "vehicleEngineType", options?.vehicleEngineType, .encode), (
                .query,
                "constantSpeedConsumptionInLitersPerHundredkm",
                options?.constantSpeedConsumptionInLitersPerHundredKm,
                .encode
            ), (.query, "currentFuelInLiters", options?.currentFuelInLiters, .encode), (
                .query,
                "auxiliaryPowerInLitersPerHour",
                options?.auxiliaryPowerInLitersPerHour,
                .encode
            ), (.query, "fuelEnergyDensityInMJoulesPerLiter", options?.fuelEnergyDensityInMegajoulesPerLiter, .encode),
            (
                .query,
                "accelerationEfficiency",
                options?.accelerationEfficiency,
                .encode
            ), (.query, "decelerationEfficiency", options?.decelerationEfficiency, .encode), (
                .query,
                "uphillEfficiency",
                options?.uphillEfficiency,
                .encode
            ), (.query, "downhillEfficiency", options?.downhillEfficiency, .encode), (
                .query,
                "constantSpeedConsumptionInkWhPerHundredkm",
                options?.constantSpeedConsumptionInKwHPerHundredKm,
                .encode
            ), (.query, "currentChargeInkWh", options?.currentChargeInKwH, .encode), (
                .query,
                "maxChargeInkWh",
                options?.maxChargeInKwH,
                .encode
            ), (.query, "auxiliaryPowerInkW", options?.auxiliaryPowerInKw, .encode), (
                .uri,
                "$host",
                client.endpoint.absoluteString,
                .skipEncoding
            ), (.header, "x-ms-client-id", client.clientId, .encode),
            (.query, "api-version", client.options.apiVersion, .encode),
            (.header, "Accept", "application/json", .encode)
        )
        // Explode query parameters
        options?.avoid?.forEach {
            params.add((.query, "avoid", $0, .encode))
        }

        // Construct request
        let urlTemplate = "/route/range/{format}"
        guard let requestUrl = client.url(host: "{$host}", template: urlTemplate, params: params),
            let request = try? HTTPRequest(method: .get, url: requestUrl, headers: params.headers)
        else {
            client.options.logger.error("Failed to construct HTTP request.")
            return
        }

        // Apply client-side validation
        var validationErrors = [String]()
        // Validate accelerationEfficiency
        if let accelerationEfficiency = options?.accelerationEfficiency, accelerationEfficiency > 1 {
            validationErrors.append("accelerationEfficiency: <= 1")
        }
        if let accelerationEfficiency = options?.accelerationEfficiency, accelerationEfficiency < 0 {
            validationErrors.append("accelerationEfficiency: >= 0")
        }
        // Validate decelerationEfficiency
        if let decelerationEfficiency = options?.decelerationEfficiency, decelerationEfficiency > 1 {
            validationErrors.append("decelerationEfficiency: <= 1")
        }
        if let decelerationEfficiency = options?.decelerationEfficiency, decelerationEfficiency < 0 {
            validationErrors.append("decelerationEfficiency: >= 0")
        }
        // Validate downhillEfficiency
        if let downhillEfficiency = options?.downhillEfficiency, downhillEfficiency > 1 {
            validationErrors.append("downhillEfficiency: <= 1")
        }
        if let downhillEfficiency = options?.downhillEfficiency, downhillEfficiency < 0 {
            validationErrors.append("downhillEfficiency: >= 0")
        }
        // Validate query
        if query.count > 2 {
            validationErrors.append("query: maxItems 2")
        }
        if query.count < 2 {
            validationErrors.append("query: minItems 2")
        }
        // Validate uphillEfficiency
        if let uphillEfficiency = options?.uphillEfficiency, uphillEfficiency > 1 {
            validationErrors.append("uphillEfficiency: <= 1")
        }
        if let uphillEfficiency = options?.uphillEfficiency, uphillEfficiency < 0 {
            validationErrors.append("uphillEfficiency: >= 0")
        }
        if !validationErrors.isEmpty {
            dispatchQueue.async {
                let error = AzureError.client("Validation Errors: \(validationErrors.joined(separator: ", "))")
                completionHandler(.failure(error), nil)
            }
            return
        }

        // Send request
        let context = PipelineContext.of(keyValues: [
            ContextKey.allowedStatusCodes.rawValue: [200] as AnyObject
        ])
        context.add(cancellationToken: options?.cancellationToken, applying: client.options)
        context.merge(with: options?.context)
        client.request(request, context: context) { result, httpResponse in
            guard let data = httpResponse?.data else {
                let noDataError = AzureError.client("Response data expected but not found.")
                dispatchQueue.async {
                    completionHandler(.failure(noDataError), httpResponse)
                }
                return
            }
            switch result {
            case .success:
                guard let statusCode = httpResponse?.statusCode else {
                    let noStatusCodeError = AzureError.client("Expected a status code in response but didn't find one.")
                    dispatchQueue.async {
                        completionHandler(.failure(noStatusCodeError), httpResponse)
                    }
                    return
                }
                if [
                    200
                ].contains(statusCode) {
                    do {
                        let decoder = JSONDecoder()
                        let decoded = try decoder.decode(RouteRangeResult.self, from: data)
                        dispatchQueue.async {
                            completionHandler(.success(decoded), httpResponse)
                        }
                    } catch {
                        dispatchQueue.async {
                            completionHandler(.failure(AzureError.client("Decoding error.", error)), httpResponse)
                        }
                    }
                }
            case .failure:
                do {
                    let decoder = JSONDecoder()
                    let decoded = try decoder.decode(ErrorResponse.self, from: data)
                    dispatchQueue.async {
                        completionHandler(
                            .failure(AzureError.service("An unexpected error occurred.", decoded)),
                            httpResponse
                        )
                    }
                } catch {
                    dispatchQueue.async {
                        completionHandler(.failure(AzureError.client("Decoding error.", error)), httpResponse)
                    }
                }
            }
        }
    }

    /// **Route Directions Batch API**
    /// **Applies to**: S1 pricing tier.
    /// The Route Directions Batch API sends batches of queries to [Route Directions API](https://docs.microsoft.com/rest/api/maps/route/getroutedirections) using just a single API call. You can call Route Directions Batch API to run either asynchronously (async) or synchronously (sync). The async API allows caller to batch up to **700** queries and sync API up to **100** queries.
    /// ### Submit Asynchronous Batch Request
    /// The Asynchronous API is appropriate for processing big volumes of relatively complex route requests
    /// - It allows the retrieval of results in a separate call (multiple downloads are possible).
    /// - The asynchronous API is optimized for reliability and is not expected to run into a timeout.
    /// - The number of batch items is limited to **700** for this API.
    /// When you make a request by using async request, by default the service returns a 202 response code along a redirect URL in the Location field of the response header. This URL should be checked periodically until the response data or error information is available.
    /// The asynchronous responses are stored for **14** days. The redirect URL returns a 404 response if used after the expiration period.
    /// Please note that asynchronous batch request is a long-running request. Here's a typical sequence of operations:
    /// 1. Client sends a Route Directions Batch `POST` request to Azure Maps
    /// 2. The server will respond with one of the following:
    ///     > HTTP `202 Accepted` - Batch request has been accepted.
    ///     > HTTP `Error` - There was an error processing your Batch request. This could either be a `400 Bad Request` or any other `Error` status code.
    /// 3. If the batch request was accepted successfully, the `Location` header in the response contains the URL to download the results of the batch request.
    ///     This status URI looks like following:
    /// ``` GET https://atlas.microsoft.com/route/directions/batch/{batch-id}?api-version=1.0 ```
    /// Note:- Please remember to add AUTH information (subscription-key/azure_auth - See [Security](#security)) to the _status URI_ before running it. <br>
    /// 4. Client issues a `GET` request on the _download URL_ obtained in Step 3 to download the batch results.
    /// ### POST Body for Batch Request
    /// To send the _route directions_ queries you will use a `POST` request where the request body will contain the `batchItems` array in `json` format and the `Content-Type` header will be set to `application/json`. Here's a sample request body containing 3 _route directions_ queries:
    /// ```json
    /// {
    ///     "batchItems": [
    ///         { "query": "?query=47.620659,-122.348934:47.610101,-122.342015&travelMode=bicycle&routeType=eco&traffic=false" },
    ///         { "query": "?query=40.759856,-73.985108:40.771136,-73.973506&travelMode=pedestrian&routeType=shortest" },
    ///         { "query": "?query=48.923159,-122.557362:32.621279,-116.840362" }
    ///     ]
    /// }
    /// ```
    /// A _route directions_ query in a batch is just a partial URL _without_ the protocol, base URL, path, api-version and subscription-key. It can accept any of the supported _route directions_ [URI parameters](https://docs.microsoft.com/rest/api/maps/route/getroutedirections#uri-parameters). The string values in the _route directions_ query must be properly escaped (e.g. " character should be escaped with \\ ) and it should also be properly URL-encoded.
    /// The async API allows caller to batch up to **700** queries and sync API up to **100** queries, and the batch should contain at least **1** query.
    /// ### Download Asynchronous Batch Results
    /// To download the async batch results you will issue a `GET` request to the batch download endpoint. This _download URL_ can be obtained from the `Location` header of a successful `POST` batch request and looks like the following:
    /// ```
    /// https://atlas.microsoft.com/route/directions/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}
    /// ```
    /// Here's the typical sequence of operations for downloading the batch results:
    /// 1. Client sends a `GET` request using the _download URL_.
    /// 2. The server will respond with one of the following:
    ///
    ///     > HTTP `202 Accepted` - Batch request was accepted but is still being processed. Please try again in some time.
    ///     > HTTP `200 OK` - Batch request successfully processed. The response body contains all the batch results.
    /// ### Batch Response Model
    /// The returned data content is similar for async and sync requests. When downloading the results of an async batch request, if the batch has finished processing, the response body contains the batch response. This batch response contains a `summary` component that indicates the `totalRequests` that were part of the original batch request and `successfulRequests`i.e. queries which were executed successfully. The batch response also includes a `batchItems` array which contains a response for each and every query in the batch request. The `batchItems` will contain the results in the exact same order the original queries were sent in the batch request. Each item in `batchItems` contains `statusCode` and `response` fields. Each `response` in `batchItems` is of one of the following types:
    ///   - [`RouteDirections`](https://docs.microsoft.com/rest/api/maps/route/getroutedirections#routedirections) - If the query completed successfully.
    ///   - `Error` - If the query failed. The response will contain a `code` and a `message` in this case.
    /// Here's a sample Batch Response with 1 _successful_ and 1 _failed_ result:
    /// ```json
    /// {
    ///     "summary": {
    ///         "successfulRequests": 1,
    ///         "totalRequests": 2
    ///     },
    ///     "batchItems": [
    ///         {
    ///             "statusCode": 200,
    ///             "response": {
    ///                 "routes": [
    ///                     {
    ///                         "summary": {
    ///                             "lengthInMeters": 1758,
    ///                             "travelTimeInSeconds": 387,
    ///                             "trafficDelayInSeconds": 0,
    ///                             "departureTime": "2018-07-17T00:49:56+00:00",
    ///                             "arrivalTime": "2018-07-17T00:56:22+00:00"
    ///                         },
    ///                         "legs": [
    ///                             {
    ///                                 "summary": {
    ///                                     "lengthInMeters": 1758,
    ///                                     "travelTimeInSeconds": 387,
    ///                                     "trafficDelayInSeconds": 0,
    ///                                     "departureTime": "2018-07-17T00:49:56+00:00",
    ///                                     "arrivalTime": "2018-07-17T00:56:22+00:00"
    ///                                 },
    ///                                 "points": [
    ///                                     {
    ///                                         "latitude": 47.62094,
    ///                                         "longitude": -122.34892
    ///                                     },
    ///                                     {
    ///                                         "latitude": 47.62094,
    ///                                         "longitude": -122.3485
    ///                                     },
    ///                                     {
    ///                                         "latitude": 47.62095,
    ///                                         "longitude": -122.3476
    ///                                     }
    ///                                 ]
    ///                             }
    ///                         ],
    ///                         "sections": [
    ///                             {
    ///                                 "startPointIndex": 0,
    ///                                 "endPointIndex": 40,
    ///                                 "sectionType": "TRAVEL_MODE",
    ///                                 "travelMode": "bicycle"
    ///                             }
    ///                         ]
    ///                     }
    ///                 ]
    ///             }
    ///         },
    ///         {
    ///             "statusCode": 400,
    ///             "response":
    ///             {
    ///                 "error":
    ///                 {
    ///                     "code": "400 BadRequest",
    ///                     "message": "Bad request: one or more parameters were incorrectly specified or are mutually exclusive."
    ///                 }
    ///             }
    ///         }
    ///     ]
    /// }
    /// ```
    /// - Parameters:
    ///    - routeDirectionsBatch : The list of route directions queries/requests to process. The list can contain a max of 700 queries for async and 100 queries for sync version and must contain at least 1 query.
    ///    - format : Desired format of the response. Only `json` format is supported.
    ///    - options: A list of options for the operation
    ///    - completionHandler: A completion handler that receives a status code on
    ///     success.
    internal func request(
        routeDirectionsBatch: BatchRequest,
        format: JsonFormat,
        withOptions options: RequestRouteDirectionsBatchOptions? = nil,
        completionHandler: @escaping HTTPResultHandler<RouteDirectionsBatchResult?>
    ) {
        let dispatchQueue = options?.dispatchQueue ?? client.commonOptions.dispatchQueue ?? DispatchQueue.main

        // Create request parameters
        let params = RequestParameters(
            (.path, "format", format, .encode), (.uri, "$host", client.endpoint.absoluteString, .skipEncoding),
            (.header, "x-ms-client-id", client.clientId, .encode),
            (.query, "api-version", client.options.apiVersion, .encode),
            (.header, "Content-Type", "application/json", .encode), (.header, "Accept", "application/json", .encode)
        )

        // Construct request
        guard let requestBody = try? JSONEncoder().encode(routeDirectionsBatch) else {
            client.options.logger.error("Failed to encode request body as json.")
            return
        }
        let urlTemplate = "/route/directions/batch/{format}"
        guard let requestUrl = client.url(host: "{$host}", template: urlTemplate, params: params),
            let request = try? HTTPRequest(method: .post, url: requestUrl, headers: params.headers, data: requestBody)
        else {
            client.options.logger.error("Failed to construct HTTP request.")
            return
        }

        // Send request
        let context = PipelineContext.of(keyValues: [
            ContextKey.allowedStatusCodes.rawValue: [200, 202] as AnyObject
        ])
        context.add(cancellationToken: options?.cancellationToken, applying: client.options)
        context.merge(with: options?.context)
        client.request(request, context: context) { result, httpResponse in
            guard let data = httpResponse?.data else {
                let noDataError = AzureError.client("Response data expected but not found.")
                dispatchQueue.async {
                    completionHandler(.failure(noDataError), httpResponse)
                }
                return
            }
            switch result {
            case .success:
                guard let statusCode = httpResponse?.statusCode else {
                    let noStatusCodeError = AzureError.client("Expected a status code in response but didn't find one.")
                    dispatchQueue.async {
                        completionHandler(.failure(noStatusCodeError), httpResponse)
                    }
                    return
                }
                if [
                    200
                ].contains(statusCode) {
                    do {
                        let decoder = JSONDecoder()
                        let decoded = try decoder.decode(RouteDirectionsBatchResult.self, from: data)
                        dispatchQueue.async {
                            completionHandler(.success(decoded), httpResponse)
                        }
                    } catch {
                        dispatchQueue.async {
                            completionHandler(.failure(AzureError.client("Decoding error.", error)), httpResponse)
                        }
                    }
                }
                if [
                    202
                ].contains(statusCode) {
                    dispatchQueue.async {
                        completionHandler(
                            .success(nil),
                            httpResponse
                        )
                    }
                }
            case .failure:
                do {
                    let decoder = JSONDecoder()
                    let decoded = try decoder.decode(ErrorResponse.self, from: data)
                    dispatchQueue.async {
                        completionHandler(
                            .failure(AzureError.service("An unexpected error occurred.", decoded)),
                            httpResponse
                        )
                    }
                } catch {
                    dispatchQueue.async {
                        completionHandler(.failure(AzureError.client("Decoding error.", error)), httpResponse)
                    }
                }
            }
        }
    }

    /// ### Download Asynchronous Batch Results
    /// To download the async batch results you will issue a `GET` request to the batch download endpoint. This _download URL_ can be obtained from the `Location` header of a successful `POST` batch request and looks like the following:
    /// ```
    /// https://atlas.microsoft.com/route/directions/batch/{batch-id}?api-version=1.0&subscription-key={subscription-key}
    /// ```
    /// Here's the typical sequence of operations for downloading the batch results:
    /// 1. Client sends a `GET` request using the _download URL_.
    /// 2. The server will respond with one of the following:
    ///
    ///     > HTTP `202 Accepted` - Batch request was accepted but is still being processed. Please try again in some time.
    ///     > HTTP `200 OK` - Batch request successfully processed. The response body contains all the batch results.
    /// ### Batch Response Model
    /// The returned data content is similar for async and sync requests. When downloading the results of an async batch request, if the batch has finished processing, the response body contains the batch response. This batch response contains a `summary` component that indicates the `totalRequests` that were part of the original batch request and `successfulRequests`i.e. queries which were executed successfully. The batch response also includes a `batchItems` array which contains a response for each and every query in the batch request. The `batchItems` will contain the results in the exact same order the original queries were sent in the batch request. Each item in `batchItems` contains `statusCode` and `response` fields. Each `response` in `batchItems` is of one of the following types:
    ///   - [`RouteDirections`](https://docs.microsoft.com/rest/api/maps/route/getroutedirections#routedirections) - If the query completed successfully.
    ///   - `Error` - If the query failed. The response will contain a `code` and a `message` in this case.
    /// Here's a sample Batch Response with 1 _successful_ and 1 _failed_ result:
    /// ```json
    /// {
    ///     "summary": {
    ///         "successfulRequests": 1,
    ///         "totalRequests": 2
    ///     },
    ///     "batchItems": [
    ///         {
    ///             "statusCode": 200,
    ///             "response": {
    ///                 "routes": [
    ///                     {
    ///                         "summary": {
    ///                             "lengthInMeters": 1758,
    ///                             "travelTimeInSeconds": 387,
    ///                             "trafficDelayInSeconds": 0,
    ///                             "departureTime": "2018-07-17T00:49:56+00:00",
    ///                             "arrivalTime": "2018-07-17T00:56:22+00:00"
    ///                         },
    ///                         "legs": [
    ///                             {
    ///                                 "summary": {
    ///                                     "lengthInMeters": 1758,
    ///                                     "travelTimeInSeconds": 387,
    ///                                     "trafficDelayInSeconds": 0,
    ///                                     "departureTime": "2018-07-17T00:49:56+00:00",
    ///                                     "arrivalTime": "2018-07-17T00:56:22+00:00"
    ///                                 },
    ///                                 "points": [
    ///                                     {
    ///                                         "latitude": 47.62094,
    ///                                         "longitude": -122.34892
    ///                                     },
    ///                                     {
    ///                                         "latitude": 47.62094,
    ///                                         "longitude": -122.3485
    ///                                     },
    ///                                     {
    ///                                         "latitude": 47.62095,
    ///                                         "longitude": -122.3476
    ///                                     }
    ///                                 ]
    ///                             }
    ///                         ],
    ///                         "sections": [
    ///                             {
    ///                                 "startPointIndex": 0,
    ///                                 "endPointIndex": 40,
    ///                                 "sectionType": "TRAVEL_MODE",
    ///                                 "travelMode": "bicycle"
    ///                             }
    ///                         ]
    ///                     }
    ///                 ]
    ///             }
    ///         },
    ///         {
    ///             "statusCode": 400,
    ///             "response":
    ///             {
    ///                 "error":
    ///                 {
    ///                     "code": "400 BadRequest",
    ///                     "message": "Bad request: one or more parameters were incorrectly specified or are mutually exclusive."
    ///                 }
    ///             }
    ///         }
    ///     ]
    /// }
    /// ```
    /// - Parameters:
    ///    - batchId : Batch id for querying the operation.
    ///    - options: A list of options for the operation
    ///    - completionHandler: A completion handler that receives a status code on
    ///     success.
    internal func getRouteDirectionsBatch(
        batchId: String,
        withOptions options: GetRouteDirectionsBatchOptions? = nil,
        completionHandler: @escaping HTTPResultHandler<RouteDirectionsBatchResult?>
    ) {
        let dispatchQueue = options?.dispatchQueue ?? client.commonOptions.dispatchQueue ?? DispatchQueue.main

        // Create request parameters
        let params = RequestParameters(
            (.path, "format", batchId, .encode), (.uri, "$host", client.endpoint.absoluteString, .skipEncoding),
            (.header, "x-ms-client-id", client.clientId, .encode),
            (.query, "api-version", client.options.apiVersion, .encode),
            (.header, "Accept", "application/json", .encode)
        )

        // Construct request
        let urlTemplate = "/route/directions/batch/{format}"
        guard let requestUrl = client.url(host: "{$host}", template: urlTemplate, params: params),
            let request = try? HTTPRequest(method: .get, url: requestUrl, headers: params.headers)
        else {
            client.options.logger.error("Failed to construct HTTP request.")
            return
        }

        // Send request
        let context = PipelineContext.of(keyValues: [
            ContextKey.allowedStatusCodes.rawValue: [200, 202] as AnyObject
        ])
        context.add(cancellationToken: options?.cancellationToken, applying: client.options)
        context.merge(with: options?.context)
        client.request(request, context: context) { result, httpResponse in
            guard let data = httpResponse?.data else {
                let noDataError = AzureError.client("Response data expected but not found.")
                dispatchQueue.async {
                    completionHandler(.failure(noDataError), httpResponse)
                }
                return
            }
            switch result {
            case .success:
                guard let statusCode = httpResponse?.statusCode else {
                    let noStatusCodeError = AzureError.client("Expected a status code in response but didn't find one.")
                    dispatchQueue.async {
                        completionHandler(.failure(noStatusCodeError), httpResponse)
                    }
                    return
                }
                if [
                    200
                ].contains(statusCode) {
                    do {
                        let decoder = JSONDecoder()
                        let decoded = try decoder.decode(RouteDirectionsBatchResult.self, from: data)
                        dispatchQueue.async {
                            completionHandler(.success(decoded), httpResponse)
                        }
                    } catch {
                        dispatchQueue.async {
                            completionHandler(.failure(AzureError.client("Decoding error.", error)), httpResponse)
                        }
                    }
                }
                if [
                    202
                ].contains(statusCode) {
                    dispatchQueue.async {
                        completionHandler(
                            .success(nil),
                            httpResponse
                        )
                    }
                }
            case .failure:
                do {
                    let decoder = JSONDecoder()
                    let decoded = try decoder.decode(ErrorResponse.self, from: data)
                    dispatchQueue.async {
                        completionHandler(
                            .failure(AzureError.service("An unexpected error occurred.", decoded)),
                            httpResponse
                        )
                    }
                } catch {
                    dispatchQueue.async {
                        completionHandler(.failure(AzureError.client("Decoding error.", error)), httpResponse)
                    }
                }
            }
        }
    }

    /// **Route Directions Batch API**
    /// **Applies to**: S1 pricing tier.
    /// The Route Directions Batch API sends batches of queries to [Route Directions API](https://docs.microsoft.com/rest/api/maps/route/getroutedirections) using just a single API call. You can call Route Directions Batch API to run either asynchronously (async) or synchronously (sync). The async API allows caller to batch up to **700** queries and sync API up to **100** queries.
    /// ### Submit Synchronous Batch Request
    /// The Synchronous API is recommended for lightweight batch requests. When the service receives a request, it will respond as soon as the batch items are calculated and there will be no possibility to retrieve the results later. The Synchronous API will return a timeout error (a 408 response) if the request takes longer than 60 seconds. The number of batch items is limited to **100** for this API.
    /// ```
    /// POST https://atlas.microsoft.com/route/directions/batch/sync/json?api-version=1.0&subscription-key={subscription-key}
    /// ```
    /// ### Batch Response Model
    /// The returned data content is similar for async and sync requests. When downloading the results of an async batch request, if the batch has finished processing, the response body contains the batch response. This batch response contains a `summary` component that indicates the `totalRequests` that were part of the original batch request and `successfulRequests`i.e. queries which were executed successfully. The batch response also includes a `batchItems` array which contains a response for each and every query in the batch request. The `batchItems` will contain the results in the exact same order the original queries were sent in the batch request. Each item in `batchItems` contains `statusCode` and `response` fields. Each `response` in `batchItems` is of one of the following types:
    ///   - [`RouteDirections`](https://docs.microsoft.com/rest/api/maps/route/getroutedirections#routedirections) - If the query completed successfully.
    ///   - `Error` - If the query failed. The response will contain a `code` and a `message` in this case.
    /// Here's a sample Batch Response with 1 _successful_ and 1 _failed_ result:
    /// ```json
    /// {
    ///     "summary": {
    ///         "successfulRequests": 1,
    ///         "totalRequests": 2
    ///     },
    ///     "batchItems": [
    ///         {
    ///             "statusCode": 200,
    ///             "response": {
    ///                 "routes": [
    ///                     {
    ///                         "summary": {
    ///                             "lengthInMeters": 1758,
    ///                             "travelTimeInSeconds": 387,
    ///                             "trafficDelayInSeconds": 0,
    ///                             "departureTime": "2018-07-17T00:49:56+00:00",
    ///                             "arrivalTime": "2018-07-17T00:56:22+00:00"
    ///                         },
    ///                         "legs": [
    ///                             {
    ///                                 "summary": {
    ///                                     "lengthInMeters": 1758,
    ///                                     "travelTimeInSeconds": 387,
    ///                                     "trafficDelayInSeconds": 0,
    ///                                     "departureTime": "2018-07-17T00:49:56+00:00",
    ///                                     "arrivalTime": "2018-07-17T00:56:22+00:00"
    ///                                 },
    ///                                 "points": [
    ///                                     {
    ///                                         "latitude": 47.62094,
    ///                                         "longitude": -122.34892
    ///                                     },
    ///                                     {
    ///                                         "latitude": 47.62094,
    ///                                         "longitude": -122.3485
    ///                                     },
    ///                                     {
    ///                                         "latitude": 47.62095,
    ///                                         "longitude": -122.3476
    ///                                     }
    ///                                 ]
    ///                             }
    ///                         ],
    ///                         "sections": [
    ///                             {
    ///                                 "startPointIndex": 0,
    ///                                 "endPointIndex": 40,
    ///                                 "sectionType": "TRAVEL_MODE",
    ///                                 "travelMode": "bicycle"
    ///                             }
    ///                         ]
    ///                     }
    ///                 ]
    ///             }
    ///         },
    ///         {
    ///             "statusCode": 400,
    ///             "response":
    ///             {
    ///                 "error":
    ///                 {
    ///                     "code": "400 BadRequest",
    ///                     "message": "Bad request: one or more parameters were incorrectly specified or are mutually exclusive."
    ///                 }
    ///             }
    ///         }
    ///     ]
    /// }
    /// ```
    /// - Parameters:
    ///    - routeDirectionsBatchSync : The list of route directions queries/requests to process. The list can contain  a max of 700 queries for async and 100 queries for sync version and must contain at least 1 query.
    ///    - format : Desired format of the response. Only `json` format is supported.
    ///    - options: A list of options for the operation
    ///    - completionHandler: A completion handler that receives a status code on
    ///     success.
    internal func request(
        routeDirectionsBatchSync: BatchRequest,
        format: JsonFormat,
        withOptions options: RequestRouteDirectionsBatchSyncOptions? = nil,
        completionHandler: @escaping HTTPResultHandler<RouteDirectionsBatchResult>
    ) {
        let dispatchQueue = options?.dispatchQueue ?? client.commonOptions.dispatchQueue ?? DispatchQueue.main

        // Create request parameters
        let params = RequestParameters(
            (.path, "format", format, .encode), (.uri, "$host", client.endpoint.absoluteString, .skipEncoding),
            (.header, "x-ms-client-id", client.clientId, .encode),
            (.query, "api-version", client.options.apiVersion, .encode),
            (.header, "Content-Type", "application/json", .encode), (.header, "Accept", "application/json", .encode)
        )

        // Construct request
        guard let requestBody = try? JSONEncoder().encode(routeDirectionsBatchSync) else {
            client.options.logger.error("Failed to encode request body as json.")
            return
        }
        let urlTemplate = "/route/directions/batch/sync/{format}"
        guard let requestUrl = client.url(host: "{$host}", template: urlTemplate, params: params),
            let request = try? HTTPRequest(method: .post, url: requestUrl, headers: params.headers, data: requestBody)
        else {
            client.options.logger.error("Failed to construct HTTP request.")
            return
        }

        // Send request
        let context = PipelineContext.of(keyValues: [
            ContextKey.allowedStatusCodes.rawValue: [200, 408] as AnyObject
        ])
        context.add(cancellationToken: options?.cancellationToken, applying: client.options)
        context.merge(with: options?.context)
        client.request(request, context: context) { result, httpResponse in
            guard let data = httpResponse?.data else {
                let noDataError = AzureError.client("Response data expected but not found.")
                dispatchQueue.async {
                    completionHandler(.failure(noDataError), httpResponse)
                }
                return
            }
            switch result {
            case .success:
                guard let statusCode = httpResponse?.statusCode else {
                    let noStatusCodeError = AzureError.client("Expected a status code in response but didn't find one.")
                    dispatchQueue.async {
                        completionHandler(.failure(noStatusCodeError), httpResponse)
                    }
                    return
                }
                if [
                    200
                ].contains(statusCode) {
                    do {
                        let decoder = JSONDecoder()
                        let decoded = try decoder.decode(RouteDirectionsBatchResult.self, from: data)
                        dispatchQueue.async {
                            completionHandler(.success(decoded), httpResponse)
                        }
                    } catch {
                        dispatchQueue.async {
                            completionHandler(.failure(AzureError.client("Decoding error.", error)), httpResponse)
                        }
                    }
                }
                if [408].contains(statusCode) {
                    do {
                        let decoder = JSONDecoder()
                        let decoded = try decoder.decode(ErrorResponse.self, from: data)
                        dispatchQueue.async {
                            completionHandler(
                                .failure(AzureError.service(
                                    "Timeout: The request took longer to finish than the maximum amount of time defined in the api.",
                                    decoded
                                )),
                                httpResponse
                            )
                        }
                    } catch {
                        dispatchQueue.async {
                            completionHandler(.failure(AzureError.client("Decoding error.", error)), httpResponse)
                        }
                    }
                }
            case .failure:
                do {
                    let decoder = JSONDecoder()
                    let decoded = try decoder.decode(ErrorResponse.self, from: data)
                    dispatchQueue.async {
                        completionHandler(
                            .failure(AzureError.service("An unexpected error occurred.", decoded)),
                            httpResponse
                        )
                    }
                } catch {
                    dispatchQueue.async {
                        completionHandler(.failure(AzureError.client("Decoding error.", error)), httpResponse)
                    }
                }
            }
        }
    }
}
