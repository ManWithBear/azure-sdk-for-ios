// --------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for
// license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// --------------------------------------------------------------------------

import AzureCore
import Foundation
// swiftlint:disable superfluous_disable_command
// swiftlint:disable identifier_name
// swiftlint:disable line_length
// swiftlint:disable cyclomatic_complexity

/// A set of attributes describing a maneuver, e.g. 'Turn right', 'Keep left', 'Take the ferry', 'Take the motorway', 'Arrive'.
public struct RouteInstruction: Codable, Swift.Error {
    // MARK: Properties

    /// Distance from the start of the route to the point of the instruction.
    public let routeOffsetInMeters: Int32?
    /// Estimated travel time up to the point corresponding to routeOffsetInMeters.
    public let travelTimeInSeconds: Int32?
    /// A location represented as a latitude and longitude.
    public let point: LatLongPair?
    /// The index of the point in the list of polyline "points" corresponding to the point of the instruction.
    public let pointIndex: Int32?
    /// Type of the instruction, e.g., turn or change of road form.
    public let instructionType: GuidanceInstructionType?
    /// The road number(s) of the next significant road segment(s) after the maneuver, or of the road(s) to be followed. Example: ["E34", "N205"]
    public let roadNumbers: [String]?
    /// The number(s) of a highway exit taken by the current maneuver. If an exit has multiple exit numbers, they will be separated by "," and possibly aggregated by "-", e.g., "10, 13-15".
    public let exitNumber: String?
    /// Street name of the next significant road segment after the maneuver, or of the street that should be followed.
    public let street: String?
    /// The text on a signpost which is most relevant to the maneuver, or to the direction that should be followed.
    public let signpostText: String?
    /// 3-character [ISO 3166-1](https://www.iso.org/iso-3166-country-codes.html) alpha-3 country code. E.g. USA.
    public let countryCode: String?
    /// A subdivision (e.g., state) of the country, represented by the second part of an [ISO 3166-2](https://www.iso.org/standard/63546.html) code. This is only available for some countries like the US, Canada, and Mexico.
    public let stateCode: String?
    /// The type of the junction where the maneuver takes place. For larger roundabouts, two separate instructions are generated for entering and leaving the roundabout.
    public let junctionType: JunctionType?
    /// Indicates the direction of an instruction. If junctionType indicates a turn instruction:
    ///   * 180 = U-turn
    ///   * [-179, -1] = Left turn
    ///   * 0 = Straight on (a '0 degree' turn)
    ///   * [1, 179] = Right turn
    /// If junctionType indicates a bifurcation instruction:
    ///   * <0 - keep left
    ///   * \>0 - keep right
    public let turnAngleInDegrees: Int32?
    /// This indicates which exit to take at a roundabout.
    public let roundaboutExitNumber: String?
    /// It is possible to optionally combine the instruction with the next one. This can be used to build messages like "Turn left and then turn right".
    public let possibleCombineWithNext: Bool?
    /// Indicates left-hand vs. right-hand side driving at the point of the maneuver.
    public let drivingSide: DrivingSide?
    /// A code identifying the maneuver.
    public let maneuver: GuidanceManeuver?
    /// A human-readable message for the maneuver.
    public let message: String?
    /// A human-readable message for the maneuver combined with the message from the next instruction. Sometimes it is possible to combine two successive instructions into a single instruction making it easier to follow. When this is the case the possibleCombineWithNext flag will be true. For example:
    /// ```
    /// 10. Turn left onto Einsteinweg/A10/E22 towards Ring Amsterdam
    /// 11. Follow Einsteinweg/A10/E22 towards Ring Amsterdam
    /// ```
    /// The possibleCombineWithNext flag on instruction 10 is true. This indicates to the clients of coded guidance that it can be combined with instruction 11. The instructions will be combined automatically for clients requesting human-readable guidance. The combinedMessage field contains the combined message:
    /// ```
    /// Turn left onto Einsteinweg/A10/E22 towards Ring Amsterdam
    /// then follow Einsteinweg/A10/E22 towards Ring Amsterdam.
    /// ```
    public let combinedMessage: String?

    // MARK: Initializers

    /// Initialize a `RouteInstruction` structure.
    /// - Parameters:
    ///   - routeOffsetInMeters: Distance from the start of the route to the point of the instruction.
    ///   - travelTimeInSeconds: Estimated travel time up to the point corresponding to routeOffsetInMeters.
    ///   - point: A location represented as a latitude and longitude.
    ///   - pointIndex: The index of the point in the list of polyline "points" corresponding to the point of the instruction.
    ///   - instructionType: Type of the instruction, e.g., turn or change of road form.
    ///   - roadNumbers: The road number(s) of the next significant road segment(s) after the maneuver, or of the road(s) to be followed. Example: ["E34", "N205"]
    ///   - exitNumber: The number(s) of a highway exit taken by the current maneuver. If an exit has multiple exit numbers, they will be separated by "," and possibly aggregated by "-", e.g., "10, 13-15".
    ///   - street: Street name of the next significant road segment after the maneuver, or of the street that should be followed.
    ///   - signpostText: The text on a signpost which is most relevant to the maneuver, or to the direction that should be followed.
    ///   - countryCode: 3-character [ISO 3166-1](https://www.iso.org/iso-3166-country-codes.html) alpha-3 country code. E.g. USA.
    ///   - stateCode: A subdivision (e.g., state) of the country, represented by the second part of an [ISO 3166-2](https://www.iso.org/standard/63546.html) code. This is only available for some countries like the US, Canada, and Mexico.
    ///   - junctionType: The type of the junction where the maneuver takes place. For larger roundabouts, two separate instructions are generated for entering and leaving the roundabout.
    ///   - turnAngleInDegrees: Indicates the direction of an instruction. If junctionType indicates a turn instruction:
    ///   * 180 = U-turn
    ///   * [-179, -1] = Left turn
    ///   * 0 = Straight on (a '0 degree' turn)
    ///   * [1, 179] = Right turn
    /// If junctionType indicates a bifurcation instruction:
    ///   * <0 - keep left
    ///   * \>0 - keep right
    ///   - roundaboutExitNumber: This indicates which exit to take at a roundabout.
    ///   - possibleCombineWithNext: It is possible to optionally combine the instruction with the next one. This can be used to build messages like "Turn left and then turn right".
    ///   - drivingSide: Indicates left-hand vs. right-hand side driving at the point of the maneuver.
    ///   - maneuver: A code identifying the maneuver.
    ///   - message: A human-readable message for the maneuver.
    ///   - combinedMessage: A human-readable message for the maneuver combined with the message from the next instruction. Sometimes it is possible to combine two successive instructions into a single instruction making it easier to follow. When this is the case the possibleCombineWithNext flag will be true. For example:
    /// ```
    /// 10. Turn left onto Einsteinweg/A10/E22 towards Ring Amsterdam
    /// 11. Follow Einsteinweg/A10/E22 towards Ring Amsterdam
    /// ```
    /// The possibleCombineWithNext flag on instruction 10 is true. This indicates to the clients of coded guidance that it can be combined with instruction 11. The instructions will be combined automatically for clients requesting human-readable guidance. The combinedMessage field contains the combined message:
    /// ```
    /// Turn left onto Einsteinweg/A10/E22 towards Ring Amsterdam
    /// then follow Einsteinweg/A10/E22 towards Ring Amsterdam.
    /// ```
    public init(
        routeOffsetInMeters: Int32? = nil, travelTimeInSeconds: Int32? = nil, point: LatLongPair? = nil,
        pointIndex: Int32? = nil, instructionType: GuidanceInstructionType? = nil, roadNumbers: [String]? = nil,
        exitNumber: String? = nil, street: String? = nil, signpostText: String? = nil, countryCode: String? = nil,
        stateCode: String? = nil, junctionType: JunctionType? = nil, turnAngleInDegrees: Int32? = nil,
        roundaboutExitNumber: String? = nil, possibleCombineWithNext: Bool? = nil, drivingSide: DrivingSide? = nil,
        maneuver: GuidanceManeuver? = nil, message: String? = nil, combinedMessage: String? = nil
    ) {
        self.routeOffsetInMeters = routeOffsetInMeters
        self.travelTimeInSeconds = travelTimeInSeconds
        self.point = point
        self.pointIndex = pointIndex
        self.instructionType = instructionType
        self.roadNumbers = roadNumbers
        self.exitNumber = exitNumber
        self.street = street
        self.signpostText = signpostText
        self.countryCode = countryCode
        self.stateCode = stateCode
        self.junctionType = junctionType
        self.turnAngleInDegrees = turnAngleInDegrees
        self.roundaboutExitNumber = roundaboutExitNumber
        self.possibleCombineWithNext = possibleCombineWithNext
        self.drivingSide = drivingSide
        self.maneuver = maneuver
        self.message = message
        self.combinedMessage = combinedMessage
    }

    // MARK: Codable

    enum CodingKeys: String, CodingKey {
        case routeOffsetInMeters = "routeOffsetInMeters"
        case travelTimeInSeconds = "travelTimeInSeconds"
        case point = "point"
        case pointIndex = "pointIndex"
        case instructionType = "instructionType"
        case roadNumbers = "roadNumbers"
        case exitNumber = "exitNumber"
        case street = "street"
        case signpostText = "signpostText"
        case countryCode = "countryCode"
        case stateCode = "stateCode"
        case junctionType = "junctionType"
        case turnAngleInDegrees = "turnAngleInDecimalDegrees"
        case roundaboutExitNumber = "roundaboutExitNumber"
        case possibleCombineWithNext = "possibleCombineWithNext"
        case drivingSide = "drivingSide"
        case maneuver = "maneuver"
        case message = "message"
        case combinedMessage = "combinedMessage"
    }

    /// Initialize a `RouteInstruction` structure from decoder
    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.routeOffsetInMeters = try? container.decode(Int32.self, forKey: .routeOffsetInMeters)
        self.travelTimeInSeconds = try? container.decode(Int32.self, forKey: .travelTimeInSeconds)
        self.point = try? container.decode(LatLongPair.self, forKey: .point)
        self.pointIndex = try? container.decode(Int32.self, forKey: .pointIndex)
        self.instructionType = try? container.decode(GuidanceInstructionType.self, forKey: .instructionType)
        self.roadNumbers = try? container.decode([String].self, forKey: .roadNumbers)
        self.exitNumber = try? container.decode(String.self, forKey: .exitNumber)
        self.street = try? container.decode(String.self, forKey: .street)
        self.signpostText = try? container.decode(String.self, forKey: .signpostText)
        self.countryCode = try? container.decode(String.self, forKey: .countryCode)
        self.stateCode = try? container.decode(String.self, forKey: .stateCode)
        self.junctionType = try? container.decode(JunctionType.self, forKey: .junctionType)
        self.turnAngleInDegrees = try? container.decode(Int32.self, forKey: .turnAngleInDegrees)
        self.roundaboutExitNumber = try? container.decode(String.self, forKey: .roundaboutExitNumber)
        self.possibleCombineWithNext = try? container.decode(Bool.self, forKey: .possibleCombineWithNext)
        self.drivingSide = try? container.decode(DrivingSide.self, forKey: .drivingSide)
        self.maneuver = try? container.decode(GuidanceManeuver.self, forKey: .maneuver)
        self.message = try? container.decode(String.self, forKey: .message)
        self.combinedMessage = try? container.decode(String.self, forKey: .combinedMessage)
    }

    /// Encode a `RouteInstruction` structure
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        if routeOffsetInMeters != nil { try? container.encode(routeOffsetInMeters, forKey: .routeOffsetInMeters) }
        if travelTimeInSeconds != nil { try? container.encode(travelTimeInSeconds, forKey: .travelTimeInSeconds) }
        if point != nil { try? container.encode(point, forKey: .point) }
        if pointIndex != nil { try? container.encode(pointIndex, forKey: .pointIndex) }
        if instructionType != nil { try? container.encode(instructionType, forKey: .instructionType) }
        if roadNumbers != nil { try? container.encode(roadNumbers, forKey: .roadNumbers) }
        if exitNumber != nil { try? container.encode(exitNumber, forKey: .exitNumber) }
        if street != nil { try? container.encode(street, forKey: .street) }
        if signpostText != nil { try? container.encode(signpostText, forKey: .signpostText) }
        if countryCode != nil { try? container.encode(countryCode, forKey: .countryCode) }
        if stateCode != nil { try? container.encode(stateCode, forKey: .stateCode) }
        if junctionType != nil { try? container.encode(junctionType, forKey: .junctionType) }
        if turnAngleInDegrees != nil { try? container.encode(turnAngleInDegrees, forKey: .turnAngleInDegrees) }
        if roundaboutExitNumber != nil { try? container.encode(roundaboutExitNumber, forKey: .roundaboutExitNumber) }
        if possibleCombineWithNext !=
            nil { try? container.encode(possibleCombineWithNext, forKey: .possibleCombineWithNext) }
        if drivingSide != nil { try? container.encode(drivingSide, forKey: .drivingSide) }
        if maneuver != nil { try? container.encode(maneuver, forKey: .maneuver) }
        if message != nil { try? container.encode(message, forKey: .message) }
        if combinedMessage != nil { try? container.encode(combinedMessage, forKey: .combinedMessage) }
    }
}
