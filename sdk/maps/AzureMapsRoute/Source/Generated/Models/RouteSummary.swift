// --------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for
// license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// --------------------------------------------------------------------------

import AzureCore
import Foundation
// swiftlint:disable superfluous_disable_command
// swiftlint:disable identifier_name
// swiftlint:disable line_length
// swiftlint:disable cyclomatic_complexity

/// Summary object
public struct RouteSummary: Codable, Swift.Error {
    // MARK: Properties

    /// Length In Meters property
    public let lengthInMeters: Int32?
    /// Estimated travel time in seconds property that includes the delay due to real-time traffic. Note that even when traffic=false travelTimeInSeconds still includes the delay due to traffic. If DepartAt is in the future, travel time is calculated using time-dependent historic traffic data.
    public let travelTimeInSeconds: Int32?
    /// Estimated delay in seconds caused by the real-time incident(s) according to traffic information. For routes planned with departure time in the future, delays is always 0. To return additional travel times using different types of traffic information, parameter computeTravelTimeFor=all needs to be added.
    public let trafficDelayInSeconds: Int32?
    /// The estimated departure time for the route or leg.
    public let departureTime: Iso8601Date?
    /// The estimated arrival time for the route or leg.
    public let arrivalTime: Iso8601Date?

    // MARK: Initializers

    /// Initialize a `RouteSummary` structure.
    /// - Parameters:
    ///   - lengthInMeters: Length In Meters property
    ///   - travelTimeInSeconds: Estimated travel time in seconds property that includes the delay due to real-time traffic. Note that even when traffic=false travelTimeInSeconds still includes the delay due to traffic. If DepartAt is in the future, travel time is calculated using time-dependent historic traffic data.
    ///   - trafficDelayInSeconds: Estimated delay in seconds caused by the real-time incident(s) according to traffic information. For routes planned with departure time in the future, delays is always 0. To return additional travel times using different types of traffic information, parameter computeTravelTimeFor=all needs to be added.
    ///   - departureTime: The estimated departure time for the route or leg.
    ///   - arrivalTime: The estimated arrival time for the route or leg.
    public init(
        lengthInMeters: Int32? = nil, travelTimeInSeconds: Int32? = nil, trafficDelayInSeconds: Int32? = nil,
        departureTime: Iso8601Date? = nil, arrivalTime: Iso8601Date? = nil
    ) {
        self.lengthInMeters = lengthInMeters
        self.travelTimeInSeconds = travelTimeInSeconds
        self.trafficDelayInSeconds = trafficDelayInSeconds
        self.departureTime = departureTime
        self.arrivalTime = arrivalTime
    }

    // MARK: Codable

    enum CodingKeys: String, CodingKey {
        case lengthInMeters = "lengthInMeters"
        case travelTimeInSeconds = "travelTimeInSeconds"
        case trafficDelayInSeconds = "trafficDelayInSeconds"
        case departureTime = "departureTime"
        case arrivalTime = "arrivalTime"
    }

    /// Initialize a `RouteSummary` structure from decoder
    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.lengthInMeters = try? container.decode(Int32.self, forKey: .lengthInMeters)
        self.travelTimeInSeconds = try? container.decode(Int32.self, forKey: .travelTimeInSeconds)
        self.trafficDelayInSeconds = try? container.decode(Int32.self, forKey: .trafficDelayInSeconds)
        self.departureTime = try? container.decode(Iso8601Date.self, forKey: .departureTime)
        self.arrivalTime = try? container.decode(Iso8601Date.self, forKey: .arrivalTime)
    }

    /// Encode a `RouteSummary` structure
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        if lengthInMeters != nil { try? container.encode(lengthInMeters, forKey: .lengthInMeters) }
        if travelTimeInSeconds != nil { try? container.encode(travelTimeInSeconds, forKey: .travelTimeInSeconds) }
        if trafficDelayInSeconds != nil { try? container.encode(trafficDelayInSeconds, forKey: .trafficDelayInSeconds) }
        if departureTime != nil { try? container.encode(departureTime, forKey: .departureTime) }
        if arrivalTime != nil { try? container.encode(arrivalTime, forKey: .arrivalTime) }
    }
}
