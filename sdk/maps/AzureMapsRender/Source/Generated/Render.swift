// --------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for
// license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// --------------------------------------------------------------------------

import AzureCore
import Foundation
// swiftlint:disable superfluous_disable_command
// swiftlint:disable file_length
// swiftlint:disable cyclomatic_complexity
// swiftlint:disable function_body_length
// swiftlint:disable type_body_length

internal final class Render {
    internal let client: RenderClientInternal

    init(client: RenderClientInternal) {
        self.client = client
    }

    /// **Applies to**: S0 and S1 pricing tiers.
    /// The Get Map Tiles API allows users to request map tiles in vector or raster formats typically to be integrated  into a map control or SDK. Some example tiles that can be requested are Azure Maps road tiles, real-time  Weather Radar tiles or the map tiles created using [Azure Maps Creator](https://aka.ms/amcreator). By default,  Azure Maps uses vector tiles for its web map control (Web SDK) and Android SDK.
    /// - Parameters:
    ///    - tilesetId : A tileset is a collection of raster or vector data broken up into a uniform grid of square tiles at preset  zoom levels. Every tileset has a **tilesetId** to use when making requests. The **tilesetId** for tilesets created using [Azure Maps Creator](https://aka.ms/amcreator) are generated through the  [Tileset Create API](https://docs.microsoft.com/en-us/rest/api/maps/tileset). The ready-to-use tilesets supplied  by Azure Maps are listed below. For example, microsoft.base.
    ///    - tileIndex : Parameter group
    ///    - options: A list of options for the operation
    ///    - completionHandler: A completion handler that receives a status code on
    ///     success.
    internal func getMapTileV2(
        tilesetId: TilesetID,
        tileIndex: TileIndex,
        withOptions options: GetMapTileV2Options? = nil,
        completionHandler: @escaping HTTPResultHandler<Void>
    ) {
        let dispatchQueue = options?.dispatchQueue ?? client.commonOptions.dispatchQueue ?? DispatchQueue.main

        // Create request parameters
        let params = RequestParameters(
            (.query, "tilesetId", tilesetId, .encode), (.query, "timeStamp", options?.timeStamp, .encode),
            (.query, "tileSize", options?.tileSize, .encode), (.query, "language", options?.language, .encode),
            (.query, "view", options?.localizedMapView, .encode),
            (.uri, "$host", client.endpoint.absoluteString, .skipEncoding),
            (.header, "x-ms-client-id", client.clientId, .encode),
            (.query, "api-version", client.options.apiVersion, .encode), (.query, "zoom", tileIndex.z, .encode),
            (.query, "x", tileIndex.x, .encode), (.query, "y", tileIndex.y, .encode), (
                .header,
                "Accept",
                "image/jpeg, image/png, image/pbf, application/vnd.mapbox-vector-tile, application/json",
                .encode
            )
        )

        // Construct request
        let urlTemplate = "/map/tile"
        guard let requestUrl = client.url(host: "{$host}", template: urlTemplate, params: params),
            let request = try? HTTPRequest(method: .get, url: requestUrl, headers: params.headers)
        else {
            client.options.logger.error("Failed to construct HTTP request.")
            return
        }

        // Send request
        let context = PipelineContext.of(keyValues: [
            ContextKey.allowedStatusCodes.rawValue: [200] as AnyObject
        ])
        context.add(cancellationToken: options?.cancellationToken, applying: client.options)
        context.merge(with: options?.context)
        client.request(request, context: context) { result, httpResponse in
            guard let data = httpResponse?.data else {
                let noDataError = AzureError.client("Response data expected but not found.")
                dispatchQueue.async {
                    completionHandler(.failure(noDataError), httpResponse)
                }
                return
            }
            switch result {
            case .success:
                guard let statusCode = httpResponse?.statusCode else {
                    let noStatusCodeError = AzureError.client("Expected a status code in response but didn't find one.")
                    dispatchQueue.async {
                        completionHandler(.failure(noStatusCodeError), httpResponse)
                    }
                    return
                }
                if [
                    200
                ].contains(statusCode) {
                    dispatchQueue.async {
                        completionHandler(
                            .success(()),
                            httpResponse
                        )
                    }
                }
            case .failure:
                do {
                    let decoder = JSONDecoder()
                    let decoded = try decoder.decode(ErrorResponse.self, from: data)
                    dispatchQueue.async {
                        completionHandler(
                            .failure(AzureError.service("An unexpected error occurred.", decoded)),
                            httpResponse
                        )
                    }
                } catch {
                    dispatchQueue.async {
                        completionHandler(.failure(AzureError.client("Decoding error.", error)), httpResponse)
                    }
                }
            }
        }
    }

    /// **Applies to**: S0 and S1 pricing tiers.
    /// The Get Map Tileset API allows users to request metadata for a tileset.
    /// - Parameters:
    ///    - tilesetId : A tileset is a collection of raster or vector data broken up into a uniform grid of square tiles at preset  zoom levels. Every tileset has a **tilesetId** to use when making requests. The **tilesetId** for tilesets created using [Azure Maps Creator](https://aka.ms/amcreator) are generated through the  [Tileset Create API](https://docs.microsoft.com/en-us/rest/api/maps/tileset). The ready-to-use tilesets supplied  by Azure Maps are listed below. For example, microsoft.base.
    ///    - options: A list of options for the operation
    ///    - completionHandler: A completion handler that receives a status code on
    ///     success.
    internal func getMapTileset(
        tilesetId: TilesetID,
        withOptions options: GetMapTilesetOptions? = nil,
        completionHandler: @escaping HTTPResultHandler<MapTileset>
    ) {
        let dispatchQueue = options?.dispatchQueue ?? client.commonOptions.dispatchQueue ?? DispatchQueue.main

        // Create request parameters
        let params = RequestParameters(
            (.query, "tilesetId", tilesetId, .encode), (.uri, "$host", client.endpoint.absoluteString, .skipEncoding),
            (.header, "x-ms-client-id", client.clientId, .encode),
            (.query, "api-version", client.options.apiVersion, .encode),
            (.header, "Accept", "application/json", .encode)
        )

        // Construct request
        let urlTemplate = "/map/tileset"
        guard let requestUrl = client.url(host: "{$host}", template: urlTemplate, params: params),
            let request = try? HTTPRequest(method: .get, url: requestUrl, headers: params.headers)
        else {
            client.options.logger.error("Failed to construct HTTP request.")
            return
        }

        // Send request
        let context = PipelineContext.of(keyValues: [
            ContextKey.allowedStatusCodes.rawValue: [200] as AnyObject
        ])
        context.add(cancellationToken: options?.cancellationToken, applying: client.options)
        context.merge(with: options?.context)
        client.request(request, context: context) { result, httpResponse in
            guard let data = httpResponse?.data else {
                let noDataError = AzureError.client("Response data expected but not found.")
                dispatchQueue.async {
                    completionHandler(.failure(noDataError), httpResponse)
                }
                return
            }
            switch result {
            case .success:
                guard let statusCode = httpResponse?.statusCode else {
                    let noStatusCodeError = AzureError.client("Expected a status code in response but didn't find one.")
                    dispatchQueue.async {
                        completionHandler(.failure(noStatusCodeError), httpResponse)
                    }
                    return
                }
                if [
                    200
                ].contains(statusCode) {
                    do {
                        let decoder = JSONDecoder()
                        let decoded = try decoder.decode(MapTileset.self, from: data)
                        dispatchQueue.async {
                            completionHandler(.success(decoded), httpResponse)
                        }
                    } catch {
                        dispatchQueue.async {
                            completionHandler(.failure(AzureError.client("Decoding error.", error)), httpResponse)
                        }
                    }
                }
            case .failure:
                do {
                    let decoder = JSONDecoder()
                    let decoded = try decoder.decode(ErrorResponse.self, from: data)
                    dispatchQueue.async {
                        completionHandler(
                            .failure(AzureError.service("An unexpected error occurred.", decoded)),
                            httpResponse
                        )
                    }
                } catch {
                    dispatchQueue.async {
                        completionHandler(.failure(AzureError.client("Decoding error.", error)), httpResponse)
                    }
                }
            }
        }
    }

    /// **Applies to**: S0 and S1 pricing tiers.
    /// The Get Map Attribution API allows users to request map copyright attribution information for a section of a tileset.
    /// - Parameters:
    ///    - tilesetId : A tileset is a collection of raster or vector data broken up into a uniform grid of square tiles at preset  zoom levels. Every tileset has a **tilesetId** to use when making requests. The **tilesetId** for tilesets created using [Azure Maps Creator](https://aka.ms/amcreator) are generated through the  [Tileset Create API](https://docs.microsoft.com/en-us/rest/api/maps/tileset). The ready-to-use tilesets supplied  by Azure Maps are listed below. For example, microsoft.base.
    ///    - zoom : Zoom level for the desired map attribution.
    ///    - bounds : The string that represents the rectangular area of a bounding box. The bounds parameter is defined by the 4 bounding box coordinates, with WGS84 longitude and latitude of the southwest corner followed by  WGS84 longitude and latitude of the northeast corner. The string is presented in the following  format: `[SouthwestCorner_Longitude, SouthwestCorner_Latitude, NortheastCorner_Longitude,  NortheastCorner_Latitude]`.
    ///    - options: A list of options for the operation
    ///    - completionHandler: A completion handler that receives a status code on
    ///     success.
    internal func getMapAttribution(
        tilesetId: TilesetID,
        zoom: Int32,
        bounds: [Double],
        withOptions options: GetMapAttributionOptions? = nil,
        completionHandler: @escaping HTTPResultHandler<MapAttribution>
    ) {
        let dispatchQueue = options?.dispatchQueue ?? client.commonOptions.dispatchQueue ?? DispatchQueue.main

        // Create request parameters
        let params = RequestParameters(
            (.query, "tilesetId", tilesetId, .encode), (.query, "zoom", zoom, .encode),
            (.query, "bounds", bounds.map { "\($0)" }.joined(separator: ","), .encode),
            (.uri, "$host", client.endpoint.absoluteString, .skipEncoding),
            (.header, "x-ms-client-id", client.clientId, .encode),
            (.query, "api-version", client.options.apiVersion, .encode),
            (.header, "Accept", "application/json", .encode)
        )

        // Construct request
        let urlTemplate = "/map/attribution"
        guard let requestUrl = client.url(host: "{$host}", template: urlTemplate, params: params),
            let request = try? HTTPRequest(method: .get, url: requestUrl, headers: params.headers)
        else {
            client.options.logger.error("Failed to construct HTTP request.")
            return
        }

        // Send request
        let context = PipelineContext.of(keyValues: [
            ContextKey.allowedStatusCodes.rawValue: [200] as AnyObject
        ])
        context.add(cancellationToken: options?.cancellationToken, applying: client.options)
        context.merge(with: options?.context)
        client.request(request, context: context) { result, httpResponse in
            guard let data = httpResponse?.data else {
                let noDataError = AzureError.client("Response data expected but not found.")
                dispatchQueue.async {
                    completionHandler(.failure(noDataError), httpResponse)
                }
                return
            }
            switch result {
            case .success:
                guard let statusCode = httpResponse?.statusCode else {
                    let noStatusCodeError = AzureError.client("Expected a status code in response but didn't find one.")
                    dispatchQueue.async {
                        completionHandler(.failure(noStatusCodeError), httpResponse)
                    }
                    return
                }
                if [
                    200
                ].contains(statusCode) {
                    do {
                        let decoder = JSONDecoder()
                        let decoded = try decoder.decode(MapAttribution.self, from: data)
                        dispatchQueue.async {
                            completionHandler(.success(decoded), httpResponse)
                        }
                    } catch {
                        dispatchQueue.async {
                            completionHandler(.failure(AzureError.client("Decoding error.", error)), httpResponse)
                        }
                    }
                }
            case .failure:
                do {
                    let decoder = JSONDecoder()
                    let decoded = try decoder.decode(ErrorResponse.self, from: data)
                    dispatchQueue.async {
                        completionHandler(
                            .failure(AzureError.service("An unexpected error occurred.", decoded)),
                            httpResponse
                        )
                    }
                } catch {
                    dispatchQueue.async {
                        completionHandler(.failure(AzureError.client("Decoding error.", error)), httpResponse)
                    }
                }
            }
        }
    }

    /// **Applies to**: S0 and S1 pricing tiers.
    /// Fetches state tiles in vector format typically to be integrated into indoor maps module of map control or SDK. The map control will call this API after user turns on dynamic styling (see [Zoom Levels and Tile Grid](https://docs.microsoft.com/en-us/azure/location-based-services/zoom-levels-and-tile-grid))
    /// - Parameters:
    ///    - statesetId : The stateset id.
    ///    - tileIndex : Parameter group
    ///    - options: A list of options for the operation
    ///    - completionHandler: A completion handler that receives a status code on
    ///     success.
    internal func getMapStateTile(
        statesetId: String,
        tileIndex: TileIndex,
        withOptions options: GetMapStateTileOptions? = nil,
        completionHandler: @escaping HTTPResultHandler<Void>
    ) {
        let dispatchQueue = options?.dispatchQueue ?? client.commonOptions.dispatchQueue ?? DispatchQueue.main

        // Create request parameters
        let params = RequestParameters(
            (.query, "statesetId", statesetId, .encode), (.uri, "$host", client.endpoint.absoluteString, .skipEncoding),
            (.header, "x-ms-client-id", client.clientId, .encode),
            (.query, "api-version", client.options.apiVersion, .encode), (.query, "zoom", tileIndex.z, .encode),
            (.query, "x", tileIndex.x, .encode), (.query, "y", tileIndex.y, .encode),
            (.header, "Accept", "application/vnd.mapbox-vector-tile, application/json", .encode)
        )

        // Construct request
        let urlTemplate = "/map/statetile"
        guard let requestUrl = client.url(host: "{$host}", template: urlTemplate, params: params),
            let request = try? HTTPRequest(method: .get, url: requestUrl, headers: params.headers)
        else {
            client.options.logger.error("Failed to construct HTTP request.")
            return
        }

        // Send request
        let context = PipelineContext.of(keyValues: [
            ContextKey.allowedStatusCodes.rawValue: [200] as AnyObject
        ])
        context.add(cancellationToken: options?.cancellationToken, applying: client.options)
        context.merge(with: options?.context)
        client.request(request, context: context) { result, httpResponse in
            guard let data = httpResponse?.data else {
                let noDataError = AzureError.client("Response data expected but not found.")
                dispatchQueue.async {
                    completionHandler(.failure(noDataError), httpResponse)
                }
                return
            }
            switch result {
            case .success:
                guard let statusCode = httpResponse?.statusCode else {
                    let noStatusCodeError = AzureError.client("Expected a status code in response but didn't find one.")
                    dispatchQueue.async {
                        completionHandler(.failure(noStatusCodeError), httpResponse)
                    }
                    return
                }
                if [
                    200
                ].contains(statusCode) {
                    dispatchQueue.async {
                        completionHandler(
                            .success(()),
                            httpResponse
                        )
                    }
                }
            case .failure:
                do {
                    let decoder = JSONDecoder()
                    let decoded = try decoder.decode(ErrorResponse.self, from: data)
                    dispatchQueue.async {
                        completionHandler(
                            .failure(AzureError.service("An unexpected error occurred.", decoded)),
                            httpResponse
                        )
                    }
                } catch {
                    dispatchQueue.async {
                        completionHandler(.failure(AzureError.client("Decoding error.", error)), httpResponse)
                    }
                }
            }
        }
    }

    /// **Applies to**: S0 and S1 pricing tiers.
    /// Copyrights API is designed to serve copyright information for Render Tile
    /// service. In addition to basic copyright for the whole map, API is serving
    /// specific groups of copyrights for some countries.
    /// As an alternative to copyrights for map request, one can receive captions
    /// for displaying the map provider information on the map.
    /// - Parameters:
    ///    - format : Desired format of the response. Value can be either _json_ or _xml_.
    ///    - options: A list of options for the operation
    ///    - completionHandler: A completion handler that receives a status code on
    ///     success.
    internal func getCopyrightCaption(
        format: ResponseFormat,
        withOptions options: GetCopyrightCaptionOptions? = nil,
        completionHandler: @escaping HTTPResultHandler<CopyrightCaption>
    ) {
        let dispatchQueue = options?.dispatchQueue ?? client.commonOptions.dispatchQueue ?? DispatchQueue.main

        // Create request parameters
        let params = RequestParameters(
            (.path, "format", format, .encode), (.uri, "$host", client.endpoint.absoluteString, .skipEncoding),
            (.header, "x-ms-client-id", client.clientId, .encode),
            (.query, "api-version", client.options.apiVersion, .encode),
            (.header, "Accept", "application/json", .encode)
        )

        // Construct request
        let urlTemplate = "/map/copyright/caption/{format}"
        guard let requestUrl = client.url(host: "{$host}", template: urlTemplate, params: params),
            let request = try? HTTPRequest(method: .get, url: requestUrl, headers: params.headers)
        else {
            client.options.logger.error("Failed to construct HTTP request.")
            return
        }

        // Send request
        let context = PipelineContext.of(keyValues: [
            ContextKey.allowedStatusCodes.rawValue: [200] as AnyObject
        ])
        context.add(cancellationToken: options?.cancellationToken, applying: client.options)
        context.merge(with: options?.context)
        client.request(request, context: context) { result, httpResponse in
            guard let data = httpResponse?.data else {
                let noDataError = AzureError.client("Response data expected but not found.")
                dispatchQueue.async {
                    completionHandler(.failure(noDataError), httpResponse)
                }
                return
            }
            switch result {
            case .success:
                guard let statusCode = httpResponse?.statusCode else {
                    let noStatusCodeError = AzureError.client("Expected a status code in response but didn't find one.")
                    dispatchQueue.async {
                        completionHandler(.failure(noStatusCodeError), httpResponse)
                    }
                    return
                }
                if [
                    200
                ].contains(statusCode) {
                    do {
                        let decoder = JSONDecoder()
                        let decoded = try decoder.decode(CopyrightCaption.self, from: data)
                        dispatchQueue.async {
                            completionHandler(.success(decoded), httpResponse)
                        }
                    } catch {
                        dispatchQueue.async {
                            completionHandler(.failure(AzureError.client("Decoding error.", error)), httpResponse)
                        }
                    }
                }
            case .failure:
                do {
                    let decoder = JSONDecoder()
                    let decoded = try decoder.decode(ErrorResponse.self, from: data)
                    dispatchQueue.async {
                        completionHandler(
                            .failure(AzureError.service("An unexpected error occurred.", decoded)),
                            httpResponse
                        )
                    }
                } catch {
                    dispatchQueue.async {
                        completionHandler(.failure(AzureError.client("Decoding error.", error)), httpResponse)
                    }
                }
            }
        }
    }

    /// **Applies to**: S0 and S1 pricing tiers.
    /// The static image service renders a user-defined, rectangular image containing a map section using a zoom level from 0 to 20. The static image service renders a user-defined, rectangular image containing a map section using a zoom level from 0 to 20. The supported resolution range for the map image is from 1x1 to 8192x8192. If you are deciding when to use the static image service over the map tile service, you may want to consider how you would like to interact with the rendered map. If the map contents will be relatively unchanging, a static map is a good choice. If you want to support a lot of zooming, panning and changing of the map content, the map tile service would be a better choice.
    /// Service also provides Image Composition functionality to get a static image back with additional data like; pushpins and geometry overlays with following S0 and S1 capabilities.
    /// In S0 you can:
    /// - Render up to 5 pushpins specified in the request
    /// - Provide one custom image for the pins referenced in the request
    /// - Add labels to the pushpins
    /// In S1 you can:
    /// - Render pushpins through [Azure Maps Data Service](https://aka.ms/AzureMapsMapDataService)
    /// - Specify multiple pushpin styles
    /// - Render circle, polyline and polygon geometry types.
    /// - Render of supported GeoJSON geometry types uploaded through [Azure Maps Data Service](https://aka.ms/AzureMapsMapDataService)
    /// Please see [How-to-Guide](https://aka.ms/AzureMapsHowToGuideImageCompositor) for detailed examples.
    /// _Note_ : Either **center** or **bbox** parameter must be supplied to the
    /// API.
    /// <br><br>
    /// The supported Lat and Lon ranges when using the **bbox** parameter, are as follows:
    /// <br><br>
    ///   |Zoom Level | Max Lon Range   | Max Lat Range|
    ///   |:----------|:----------------|:-------------|
    ///   |0          | 360.0           | 170.0        |
    ///   |1          | 360.0           | 170.0        |
    ///   |2          | 360.0           | 170.0        |
    ///   |3          | 360.0           | 170.0        |
    ///   |4          | 360.0           | 170.0        |
    ///   |5          | 180.0           | 85.0         |
    ///   |6          | 90.0            | 42.5         |
    ///   |7          | 45.0            | 21.25        |
    ///   |8          | 22.5            | 10.625       |
    ///   |9          | 11.25           | 5.3125       |
    ///   |10         | 5.625           | 2.62625      |
    ///   |11         | 2.8125          | 1.328125     |
    ///   |12         | 1.40625         | 0.6640625    |
    ///   |13         | 0.703125        | 0.33203125   |
    ///   |14         | 0.3515625       | 0.166015625  |
    ///   |15         | 0.17578125      | 0.0830078125 |
    ///   |16         | 0.087890625     | 0.0415039063 |
    ///   |17         | 0.0439453125    | 0.0207519531 |
    ///   |18         | 0.0219726563    | 0.0103759766 |
    ///   |19         | 0.0109863281    | 0.0051879883 |
    ///   |20         | 0.0054931641    | 0.0025939941 |
    /// - Parameters:
    ///    - format : Desired format of the response. Possible value: png.
    ///    - options: A list of options for the operation
    ///    - completionHandler: A completion handler that receives a status code on
    ///     success.
    internal func getMapStaticImage(
        format: RasterTileFormat,
        withOptions options: GetMapStaticImageOptions? = nil,
        completionHandler: @escaping HTTPResultHandler<Void>
    ) {
        let dispatchQueue = options?.dispatchQueue ?? client.commonOptions.dispatchQueue ?? DispatchQueue.main

        // Create request parameters
        var params = RequestParameters(
            (.path, "format", format, .encode), (.query, "layer", options?.layer, .encode),
            (.query, "style", options?.style, .encode), (.query, "zoom", options?.zoom, .encode),
            (.query, "center", options?.center?.map { "\($0)" }.joined(separator: ","), .encode),
            (.query, "bbox", options?.boundingBox?.map { "\($0)" }.joined(separator: ","), .encode),
            (.query, "height", options?.height, .encode), (.query, "width", options?.width, .encode),
            (.query, "language", options?.language, .encode), (.query, "view", options?.localizedMapView, .encode),
            (.uri, "$host", client.endpoint.absoluteString, .skipEncoding),
            (.header, "x-ms-client-id", client.clientId, .encode),
            (.query, "api-version", client.options.apiVersion, .encode), (
                .header,
                "Accept",
                "image/jpeg, image/png, image/pbf, application/vnd.mapbox-vector-tile, application/json",
                .encode
            )
        )
        // Explode query parameters
        options?.pins?.forEach {
            params.add((.query, "pins", $0, .encode))
        }
        options?.path?.forEach {
            params.add((.query, "path", $0, .encode))
        }

        // Construct request
        let urlTemplate = "/map/static/{format}"
        guard let requestUrl = client.url(host: "{$host}", template: urlTemplate, params: params),
            let request = try? HTTPRequest(method: .get, url: requestUrl, headers: params.headers)
        else {
            client.options.logger.error("Failed to construct HTTP request.")
            return
        }

        // Apply client-side validation
        var validationErrors = [String]()
        // Validate height
        if let height = options?.height, height > 8192 {
            validationErrors.append("height: <= 8192")
        }
        if let height = options?.height, height < 1 {
            validationErrors.append("height: >= 1")
        }
        // Validate width
        if let width = options?.width, width > 8192 {
            validationErrors.append("width: <= 8192")
        }
        if let width = options?.width, width < 1 {
            validationErrors.append("width: >= 1")
        }
        // Validate zoom
        if let zoom = options?.zoom, zoom > 20 {
            validationErrors.append("zoom: <= 20")
        }
        if let zoom = options?.zoom, zoom < 0 {
            validationErrors.append("zoom: >= 0")
        }
        if !validationErrors.isEmpty {
            dispatchQueue.async {
                let error = AzureError.client("Validation Errors: \(validationErrors.joined(separator: ", "))")
                completionHandler(.failure(error), nil)
            }
            return
        }

        // Send request
        let context = PipelineContext.of(keyValues: [
            ContextKey.allowedStatusCodes.rawValue: [200] as AnyObject
        ])
        context.add(cancellationToken: options?.cancellationToken, applying: client.options)
        context.merge(with: options?.context)
        client.request(request, context: context) { result, httpResponse in
            guard let data = httpResponse?.data else {
                let noDataError = AzureError.client("Response data expected but not found.")
                dispatchQueue.async {
                    completionHandler(.failure(noDataError), httpResponse)
                }
                return
            }
            switch result {
            case .success:
                guard let statusCode = httpResponse?.statusCode else {
                    let noStatusCodeError = AzureError.client("Expected a status code in response but didn't find one.")
                    dispatchQueue.async {
                        completionHandler(.failure(noStatusCodeError), httpResponse)
                    }
                    return
                }
                if [
                    200
                ].contains(statusCode) {
                    dispatchQueue.async {
                        completionHandler(
                            .success(()),
                            httpResponse
                        )
                    }
                }
            case .failure:
                do {
                    let decoder = JSONDecoder()
                    let decoded = try decoder.decode(ErrorResponse.self, from: data)
                    dispatchQueue.async {
                        completionHandler(
                            .failure(AzureError.service("An unexpected error occurred.", decoded)),
                            httpResponse
                        )
                    }
                } catch {
                    dispatchQueue.async {
                        completionHandler(.failure(AzureError.client("Decoding error.", error)), httpResponse)
                    }
                }
            }
        }
    }

    /// **Applies to**: S0 and S1 pricing tiers.
    /// Returns copyright information for a given bounding box. Bounding-box requests should specify the minimum and maximum longitude and latitude (EPSG-3857) coordinates
    /// - Parameters:
    ///    - format : Desired format of the response. Value can be either _json_ or _xml_.
    ///    - boundingBox : Parameter group
    ///    - options: A list of options for the operation
    ///    - completionHandler: A completion handler that receives a status code on
    ///     success.
    internal func getCopyrightFromBoundingBox(
        format: ResponseFormat,
        boundingBox: BoundingBox,
        withOptions options: GetCopyrightFromBoundingBoxOptions? = nil,
        completionHandler: @escaping HTTPResultHandler<Copyright>
    ) {
        let dispatchQueue = options?.dispatchQueue ?? client.commonOptions.dispatchQueue ?? DispatchQueue.main

        // Create request parameters
        let params = RequestParameters(
            (.path, "format", format, .encode), (.query, "text", options?.includeText, .encode),
            (.uri, "$host", client.endpoint.absoluteString, .skipEncoding),
            (.header, "x-ms-client-id", client.clientId, .encode),
            (.query, "api-version", client.options.apiVersion, .encode),
            (.query, "mincoordinates", boundingBox.southWest, .encode),
            (.query, "maxcoordinates", boundingBox.northEast, .encode), (.header, "Accept", "application/json", .encode)
        )

        // Construct request
        let urlTemplate = "/map/copyright/bounding/{format}"
        guard let requestUrl = client.url(host: "{$host}", template: urlTemplate, params: params),
            let request = try? HTTPRequest(method: .get, url: requestUrl, headers: params.headers)
        else {
            client.options.logger.error("Failed to construct HTTP request.")
            return
        }

        // Send request
        let context = PipelineContext.of(keyValues: [
            ContextKey.allowedStatusCodes.rawValue: [200] as AnyObject
        ])
        context.add(cancellationToken: options?.cancellationToken, applying: client.options)
        context.merge(with: options?.context)
        client.request(request, context: context) { result, httpResponse in
            guard let data = httpResponse?.data else {
                let noDataError = AzureError.client("Response data expected but not found.")
                dispatchQueue.async {
                    completionHandler(.failure(noDataError), httpResponse)
                }
                return
            }
            switch result {
            case .success:
                guard let statusCode = httpResponse?.statusCode else {
                    let noStatusCodeError = AzureError.client("Expected a status code in response but didn't find one.")
                    dispatchQueue.async {
                        completionHandler(.failure(noStatusCodeError), httpResponse)
                    }
                    return
                }
                if [
                    200
                ].contains(statusCode) {
                    do {
                        let decoder = JSONDecoder()
                        let decoded = try decoder.decode(Copyright.self, from: data)
                        dispatchQueue.async {
                            completionHandler(.success(decoded), httpResponse)
                        }
                    } catch {
                        dispatchQueue.async {
                            completionHandler(.failure(AzureError.client("Decoding error.", error)), httpResponse)
                        }
                    }
                }
            case .failure:
                do {
                    let decoder = JSONDecoder()
                    let decoded = try decoder.decode(ErrorResponse.self, from: data)
                    dispatchQueue.async {
                        completionHandler(
                            .failure(AzureError.service("An unexpected error occurred.", decoded)),
                            httpResponse
                        )
                    }
                } catch {
                    dispatchQueue.async {
                        completionHandler(.failure(AzureError.client("Decoding error.", error)), httpResponse)
                    }
                }
            }
        }
    }

    /// **Applies to**: S0 and S1 pricing tiers.
    /// Copyrights API is designed to serve copyright information for Render Tile  service. In addition to basic copyright for the whole map, API is serving  specific groups of copyrights for some countries.
    /// Returns the copyright information for a given tile. To obtain the copyright information for a particular tile, the request should specify the tile's zoom level and x and y coordinates (see: Zoom Levels and Tile Grid).
    /// - Parameters:
    ///    - format : Desired format of the response. Value can be either _json_ or _xml_.
    ///    - tileIndex : Parameter group
    ///    - options: A list of options for the operation
    ///    - completionHandler: A completion handler that receives a status code on
    ///     success.
    internal func getCopyrightForTile(
        format: ResponseFormat,
        tileIndex: TileIndex,
        withOptions options: GetCopyrightForTileOptions? = nil,
        completionHandler: @escaping HTTPResultHandler<Copyright>
    ) {
        let dispatchQueue = options?.dispatchQueue ?? client.commonOptions.dispatchQueue ?? DispatchQueue.main

        // Create request parameters
        let params = RequestParameters(
            (.path, "format", format, .encode), (.query, "text", options?.includeText, .encode),
            (.uri, "$host", client.endpoint.absoluteString, .skipEncoding),
            (.header, "x-ms-client-id", client.clientId, .encode),
            (.query, "api-version", client.options.apiVersion, .encode), (.query, "zoom", tileIndex.z, .encode),
            (.query, "x", tileIndex.x, .encode), (.query, "y", tileIndex.y, .encode),
            (.header, "Accept", "application/json", .encode)
        )

        // Construct request
        let urlTemplate = "/map/copyright/tile/{format}"
        guard let requestUrl = client.url(host: "{$host}", template: urlTemplate, params: params),
            let request = try? HTTPRequest(method: .get, url: requestUrl, headers: params.headers)
        else {
            client.options.logger.error("Failed to construct HTTP request.")
            return
        }

        // Send request
        let context = PipelineContext.of(keyValues: [
            ContextKey.allowedStatusCodes.rawValue: [200] as AnyObject
        ])
        context.add(cancellationToken: options?.cancellationToken, applying: client.options)
        context.merge(with: options?.context)
        client.request(request, context: context) { result, httpResponse in
            guard let data = httpResponse?.data else {
                let noDataError = AzureError.client("Response data expected but not found.")
                dispatchQueue.async {
                    completionHandler(.failure(noDataError), httpResponse)
                }
                return
            }
            switch result {
            case .success:
                guard let statusCode = httpResponse?.statusCode else {
                    let noStatusCodeError = AzureError.client("Expected a status code in response but didn't find one.")
                    dispatchQueue.async {
                        completionHandler(.failure(noStatusCodeError), httpResponse)
                    }
                    return
                }
                if [
                    200
                ].contains(statusCode) {
                    do {
                        let decoder = JSONDecoder()
                        let decoded = try decoder.decode(Copyright.self, from: data)
                        dispatchQueue.async {
                            completionHandler(.success(decoded), httpResponse)
                        }
                    } catch {
                        dispatchQueue.async {
                            completionHandler(.failure(AzureError.client("Decoding error.", error)), httpResponse)
                        }
                    }
                }
            case .failure:
                do {
                    let decoder = JSONDecoder()
                    let decoded = try decoder.decode(ErrorResponse.self, from: data)
                    dispatchQueue.async {
                        completionHandler(
                            .failure(AzureError.service("An unexpected error occurred.", decoded)),
                            httpResponse
                        )
                    }
                } catch {
                    dispatchQueue.async {
                        completionHandler(.failure(AzureError.client("Decoding error.", error)), httpResponse)
                    }
                }
            }
        }
    }

    /// **Applies to**: S0 and S1 pricing tiers.
    /// Copyrights API is designed to serve copyright information for Render Tile  service. In addition to basic copyright for the whole map, API is serving  specific groups of copyrights for some countries.
    /// Returns the copyright information for the world. To obtain the default copyright information for the whole world, do not specify a tile or bounding box.
    /// - Parameters:
    ///    - format : Desired format of the response. Value can be either _json_ or _xml_.
    ///    - options: A list of options for the operation
    ///    - completionHandler: A completion handler that receives a status code on
    ///     success.
    internal func getCopyrightForWorld(
        format: ResponseFormat,
        withOptions options: GetCopyrightForWorldOptions? = nil,
        completionHandler: @escaping HTTPResultHandler<Copyright>
    ) {
        let dispatchQueue = options?.dispatchQueue ?? client.commonOptions.dispatchQueue ?? DispatchQueue.main

        // Create request parameters
        let params = RequestParameters(
            (.path, "format", format, .encode), (.query, "text", options?.includeText, .encode),
            (.uri, "$host", client.endpoint.absoluteString, .skipEncoding),
            (.header, "x-ms-client-id", client.clientId, .encode),
            (.query, "api-version", client.options.apiVersion, .encode),
            (.header, "Accept", "application/json", .encode)
        )

        // Construct request
        let urlTemplate = "/map/copyright/world/{format}"
        guard let requestUrl = client.url(host: "{$host}", template: urlTemplate, params: params),
            let request = try? HTTPRequest(method: .get, url: requestUrl, headers: params.headers)
        else {
            client.options.logger.error("Failed to construct HTTP request.")
            return
        }

        // Send request
        let context = PipelineContext.of(keyValues: [
            ContextKey.allowedStatusCodes.rawValue: [200] as AnyObject
        ])
        context.add(cancellationToken: options?.cancellationToken, applying: client.options)
        context.merge(with: options?.context)
        client.request(request, context: context) { result, httpResponse in
            guard let data = httpResponse?.data else {
                let noDataError = AzureError.client("Response data expected but not found.")
                dispatchQueue.async {
                    completionHandler(.failure(noDataError), httpResponse)
                }
                return
            }
            switch result {
            case .success:
                guard let statusCode = httpResponse?.statusCode else {
                    let noStatusCodeError = AzureError.client("Expected a status code in response but didn't find one.")
                    dispatchQueue.async {
                        completionHandler(.failure(noStatusCodeError), httpResponse)
                    }
                    return
                }
                if [
                    200
                ].contains(statusCode) {
                    do {
                        let decoder = JSONDecoder()
                        let decoded = try decoder.decode(Copyright.self, from: data)
                        dispatchQueue.async {
                            completionHandler(.success(decoded), httpResponse)
                        }
                    } catch {
                        dispatchQueue.async {
                            completionHandler(.failure(AzureError.client("Decoding error.", error)), httpResponse)
                        }
                    }
                }
            case .failure:
                do {
                    let decoder = JSONDecoder()
                    let decoded = try decoder.decode(ErrorResponse.self, from: data)
                    dispatchQueue.async {
                        completionHandler(
                            .failure(AzureError.service("An unexpected error occurred.", decoded)),
                            httpResponse
                        )
                    }
                } catch {
                    dispatchQueue.async {
                        completionHandler(.failure(AzureError.client("Decoding error.", error)), httpResponse)
                    }
                }
            }
        }
    }
}
