// --------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for
// license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// --------------------------------------------------------------------------

import AzureCore
import Foundation

public enum TilesetID: RequestStringConvertible, Codable, Equatable {
    /// Custom value for unrecognized enum values
    case custom(String)
    /// A base map is a standard map that displays roads, natural and artificial features along with the labels for those features in a vector tile.<br>
    /// Supports zoom levels 0 through 22. Format: vector (pbf).
    case microsoftBase
    /// Displays labels for roads, natural and artificial features in a vector tile.<br>
    /// Supports zoom levels 0 through 22. Format: vector (pbf).
    case microsoftBaseLabels
    /// Displays road, boundary and label data in a vector tile.<br>
    /// Supports zoom levels 0 through 22. Format: vector (pbf).
    case microsoftBaseHybrid
    /// Shaded relief and terra layers.<br>
    /// Supports zoom levels 0 through 6. Format: raster (png).
    case microsoftTerraMain
    /// All layers with our main style.<br>
    /// Supports zoom levels 0 through 22. Format: raster (png).
    case microsoftBaseRoad
    /// All layers with our dark grey style.<br>
    /// Supports zoom levels 0 through 22. Format: raster (png).
    case microsoftBaseDarkgrey
    /// Label data in our main style.<br>
    /// Supports zoom levels 0 through 22. Format: raster (png).
    case microsoftBaseLabelsRoad
    /// Label data in our dark grey style.<br>
    /// Supports zoom levels 0 through 22. Format: raster (png).
    case microsoftBaseLabelsDarkgrey
    /// Road, boundary and label data in our main style.<br>
    /// Supports zoom levels 0 through 22. Format: raster (png).
    case microsoftBaseHybridRoad
    /// Road, boundary and label data in our dark grey style.<br>
    /// Supports zoom levels 0 through 22. Format: raster (png).
    case microsoftBaseHybridDarkgrey
    /// A combination of satellite and aerial imagery. Only available in S1 pricing SKU.<br>
    /// Supports zoom levels 1 through 19. Format: raster (jpeg).
    case microsoftImagery
    /// Weather radar tiles. Latest weather radar images including areas of rain, snow, ice and mixed conditions. Please see [coverage information](https://aka.ms/AzureMapsWeatherCoverage) for Azure Maps Weather service.  To learn more about the Radar data, please see [Weather concepts](https://aka.ms/AzureMapsWeatherConcepts).<br>
    /// Supports zoom levels 0 through 15. Format: raster (png).
    case microsoftWeatherRadarMain
    /// Weather infrared tiles. Latest Infrared Satellite images shows clouds by their temperature.  Please see [coverage information](https://aka.ms/AzureMapsWeatherCoverage) for Azure Maps Weather service. To learn more about the returned Satellite data, please see [Weather concepts](https://aka.ms/AzureMapsWeatherConcepts).<br>
    /// Supports zoom levels 0 through 15. Format: raster (png).
    case microsoftWeatherInfraredMain
    /// Digital Elevation Model tiles. The tiles are in the GeoTIFF format with a single 32-bit floating point band. The tiles cover the whole landmass of Earth. Some small islands (e.g., atolls) might not be represented accurately.<br>
    /// * The vertical unit for measurement of elevation height is meters. An elevation value of -32767.0 is used for points that have no data value, most often returned where there isn't landmass (i.e. water).<br>
    /// * The horizontal reference datum is the World Geodetic System 1984 (WGS84-G1150) and the vertical reference datum is the Earth Gravitational Model 2008 (EGM2008).<br>
    /// * Tiles are 258x258 pixel squares rather than the standard 256 x 256. This is done to allow for accurate interpolation of values at the tile edges. As such adjacent tiles overlap by 1 pixel along all edges.<br>
    /// * Tile data comes from the [Airbus WorldDEM4Ortho product](https://www.intelligence-airbusds.com/worlddem-streaming/). Urban areas are approximately leveled down to ground level. All other areas are represented by the object surface level (e.g., trees). <br>
    /// Supports zoom level 13 only. Format: raster (tiff).
    case microsoftDem
    /// Digital elevation contour line tiles. Compared to the microsoft.dem option, these tiles are in vector format and intended for visualization purpose. The tiles cover the whole landmass of Earth. Some small islands (e.g., atolls) might not be represented accurately.<br>
    /// * The vertical unit for measurement of elevation height is meters.<br>
    /// * The horizontal reference datum is the World Geodetic System 1984 (WGS84-G1150) and the vertical reference datum is the Earth Gravitational Model 2008 (EGM2008).<br>
    /// * Tile data comes from the [Airbus WorldDEM4Ortho product](https://www.intelligence-airbusds.com/worlddem-streaming/). Urban areas are approximately leveled down to ground level. All other areas are represented by the object surface level (e.g., trees).<br>
    /// Supports zoom levels 9 through 14. Format: vector (pbf).
    case microsoftDemContours
    /// absolute traffic tiles in vector
    case microsoftTrafficAbsolute
    /// absolute traffic tiles in raster in our main style.
    case microsoftTrafficAbsoluteMain
    /// relative traffic tiles in vector
    case microsoftTrafficRelative
    /// relative traffic tiles in raster in our main style.
    case microsoftTrafficRelativeMain
    /// relative traffic tiles in raster in our dark style.
    case microsoftTrafficRelativeDark
    /// traffic tiles in vector
    case microsoftTrafficDelay
    /// traffic tiles in raster in our main style
    case microsoftTrafficDelayMain
    /// reduced traffic tiles in raster in our main style
    case microsoftTrafficReducedMain
    /// incident tiles in vector
    case microsoftTrafficIncident

    public var requestString: String {
        switch self {
        case let .custom(val):
            return val
        case .microsoftBase:
            return "microsoft.base"
        case .microsoftBaseLabels:
            return "microsoft.base.labels"
        case .microsoftBaseHybrid:
            return "microsoft.base.hybrid"
        case .microsoftTerraMain:
            return "microsoft.terra.main"
        case .microsoftBaseRoad:
            return "microsoft.base.road"
        case .microsoftBaseDarkgrey:
            return "microsoft.base.darkgrey"
        case .microsoftBaseLabelsRoad:
            return "microsoft.base.labels.road"
        case .microsoftBaseLabelsDarkgrey:
            return "microsoft.base.labels.darkgrey"
        case .microsoftBaseHybridRoad:
            return "microsoft.base.hybrid.road"
        case .microsoftBaseHybridDarkgrey:
            return "microsoft.base.hybrid.darkgrey"
        case .microsoftImagery:
            return "microsoft.imagery"
        case .microsoftWeatherRadarMain:
            return "microsoft.weather.radar.main"
        case .microsoftWeatherInfraredMain:
            return "microsoft.weather.infrared.main"
        case .microsoftDem:
            return "microsoft.dem"
        case .microsoftDemContours:
            return "microsoft.dem.contours"
        case .microsoftTrafficAbsolute:
            return "microsoft.traffic.absolute"
        case .microsoftTrafficAbsoluteMain:
            return "microsoft.traffic.absolute.main"
        case .microsoftTrafficRelative:
            return "microsoft.traffic.relative"
        case .microsoftTrafficRelativeMain:
            return "microsoft.traffic.relative.main"
        case .microsoftTrafficRelativeDark:
            return "microsoft.traffic.relative.dark"
        case .microsoftTrafficDelay:
            return "microsoft.traffic.delay"
        case .microsoftTrafficDelayMain:
            return "microsoft.traffic.delay.main"
        case .microsoftTrafficReducedMain:
            return "microsoft.traffic.reduced.main"
        case .microsoftTrafficIncident:
            return "microsoft.traffic.incident"
        }
    }

    public init(_ val: String) {
        switch val.lowercased() {
        case "microsoft.base":
            self = .microsoftBase
        case "microsoft.base.labels":
            self = .microsoftBaseLabels
        case "microsoft.base.hybrid":
            self = .microsoftBaseHybrid
        case "microsoft.terra.main":
            self = .microsoftTerraMain
        case "microsoft.base.road":
            self = .microsoftBaseRoad
        case "microsoft.base.darkgrey":
            self = .microsoftBaseDarkgrey
        case "microsoft.base.labels.road":
            self = .microsoftBaseLabelsRoad
        case "microsoft.base.labels.darkgrey":
            self = .microsoftBaseLabelsDarkgrey
        case "microsoft.base.hybrid.road":
            self = .microsoftBaseHybridRoad
        case "microsoft.base.hybrid.darkgrey":
            self = .microsoftBaseHybridDarkgrey
        case "microsoft.imagery":
            self = .microsoftImagery
        case "microsoft.weather.radar.main":
            self = .microsoftWeatherRadarMain
        case "microsoft.weather.infrared.main":
            self = .microsoftWeatherInfraredMain
        case "microsoft.dem":
            self = .microsoftDem
        case "microsoft.dem.contours":
            self = .microsoftDemContours
        case "microsoft.traffic.absolute":
            self = .microsoftTrafficAbsolute
        case "microsoft.traffic.absolute.main":
            self = .microsoftTrafficAbsoluteMain
        case "microsoft.traffic.relative":
            self = .microsoftTrafficRelative
        case "microsoft.traffic.relative.main":
            self = .microsoftTrafficRelativeMain
        case "microsoft.traffic.relative.dark":
            self = .microsoftTrafficRelativeDark
        case "microsoft.traffic.delay":
            self = .microsoftTrafficDelay
        case "microsoft.traffic.delay.main":
            self = .microsoftTrafficDelayMain
        case "microsoft.traffic.reduced.main":
            self = .microsoftTrafficReducedMain
        case "microsoft.traffic.incident":
            self = .microsoftTrafficIncident
        default:
            self = .custom(val)
        }
    }

    // MARK: Codable

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let value = try container.decode(String.self)
        self.init(value)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(requestString)
    }
}

public enum MapTileSize: RequestStringConvertible, Codable, Equatable {
    /// Custom value for unrecognized enum values
    case custom(String)
    /// Return a 256 by 256 pixel tile.
    case size256
    /// Return a 512 by 512 pixel tile.
    case size512

    public var requestString: String {
        switch self {
        case let .custom(val):
            return val
        case .size256:
            return "256"
        case .size512:
            return "512"
        }
    }

    public init(_ val: String) {
        switch val.lowercased() {
        case "256":
            self = .size256
        case "512":
            self = .size512
        default:
            self = .custom(val)
        }
    }

    // MARK: Codable

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let value = try container.decode(String.self)
        self.init(value)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(requestString)
    }
}

public enum LocalizedMapView: RequestStringConvertible, Codable, Equatable {
    /// Custom value for unrecognized enum values
    case custom(String)
    /// United Arab Emirates (Arabic View)
    case aE
    /// Argentina (Argentinian View)
    case aR
    /// Bahrain (Arabic View)
    case bH
    /// India (Indian View)
    case iN
    /// Iraq (Arabic View)
    case iQ
    /// Jordan (Arabic View)
    case jO
    /// Kuwait (Arabic View)
    case kW
    /// Lebanon (Arabic View)
    case lB
    /// Morocco (Moroccan View)
    case mA
    /// Oman (Arabic View)
    case oM
    /// Pakistan (Pakistani View)
    case pK
    /// Palestinian Authority (Arabic View)
    case pS
    /// Qatar (Arabic View)
    case qA
    /// Saudi Arabia (Arabic View)
    case sA
    /// Syria (Arabic View)
    case sY
    /// Yemen (Arabic View)
    case yE
    /// Return the map data based on the IP address of the request.
    case auto
    /// Unified View (Others)
    case unified

    public var requestString: String {
        switch self {
        case let .custom(val):
            return val
        case .aE:
            return "AE"
        case .aR:
            return "AR"
        case .bH:
            return "BH"
        case .iN:
            return "IN"
        case .iQ:
            return "IQ"
        case .jO:
            return "JO"
        case .kW:
            return "KW"
        case .lB:
            return "LB"
        case .mA:
            return "MA"
        case .oM:
            return "OM"
        case .pK:
            return "PK"
        case .pS:
            return "PS"
        case .qA:
            return "QA"
        case .sA:
            return "SA"
        case .sY:
            return "SY"
        case .yE:
            return "YE"
        case .auto:
            return "Auto"
        case .unified:
            return "Unified"
        }
    }

    public init(_ val: String) {
        switch val.lowercased() {
        case "ae":
            self = .aE
        case "ar":
            self = .aR
        case "bh":
            self = .bH
        case "in":
            self = .iN
        case "iq":
            self = .iQ
        case "jo":
            self = .jO
        case "kw":
            self = .kW
        case "lb":
            self = .lB
        case "ma":
            self = .mA
        case "om":
            self = .oM
        case "pk":
            self = .pK
        case "ps":
            self = .pS
        case "qa":
            self = .qA
        case "sa":
            self = .sA
        case "sy":
            self = .sY
        case "ye":
            self = .yE
        case "auto":
            self = .auto
        case "unified":
            self = .unified
        default:
            self = .custom(val)
        }
    }

    // MARK: Codable

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let value = try container.decode(String.self)
        self.init(value)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(requestString)
    }
}

public enum ResponseFormat: RequestStringConvertible, Codable, Equatable {
    /// Custom value for unrecognized enum values
    case custom(String)
    /// [The JavaScript Object Notation Data Interchange Format](https://tools.ietf.org/html/rfc8259)
    case json
    /// [The Extensible Markup Language](https://www.w3.org/TR/xml/)
    case xml

    public var requestString: String {
        switch self {
        case let .custom(val):
            return val
        case .json:
            return "json"
        case .xml:
            return "xml"
        }
    }

    public init(_ val: String) {
        switch val.lowercased() {
        case "json":
            self = .json
        case "xml":
            self = .xml
        default:
            self = .custom(val)
        }
    }

    // MARK: Codable

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let value = try container.decode(String.self)
        self.init(value)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(requestString)
    }
}

public enum RasterTileFormat: RequestStringConvertible, Codable, Equatable {
    /// Custom value for unrecognized enum values
    case custom(String)
    /// An image in the png format. Supports zoom levels 0 through 18.
    case png

    public var requestString: String {
        switch self {
        case let .custom(val):
            return val
        case .png:
            return "png"
        }
    }

    public init(_ val: String) {
        switch val.lowercased() {
        case "png":
            self = .png
        default:
            self = .custom(val)
        }
    }

    // MARK: Codable

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let value = try container.decode(String.self)
        self.init(value)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(requestString)
    }
}

public enum StaticMapLayer: RequestStringConvertible, Codable, Equatable {
    /// Custom value for unrecognized enum values
    case custom(String)
    /// Returns an image containing all map features including polygons, borders, roads and labels.
    case basic
    /// Returns an image containing borders, roads, and labels, and can be overlaid on other tiles (such as satellite imagery) to produce hybrid tiles.
    case hybrid
    /// Returns an image of just the map's label information.
    case labels

    public var requestString: String {
        switch self {
        case let .custom(val):
            return val
        case .basic:
            return "basic"
        case .hybrid:
            return "hybrid"
        case .labels:
            return "labels"
        }
    }

    public init(_ val: String) {
        switch val.lowercased() {
        case "basic":
            self = .basic
        case "hybrid":
            self = .hybrid
        case "labels":
            self = .labels
        default:
            self = .custom(val)
        }
    }

    // MARK: Codable

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let value = try container.decode(String.self)
        self.init(value)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(requestString)
    }
}

public enum MapImageStyle: RequestStringConvertible, Codable, Equatable {
    /// Custom value for unrecognized enum values
    case custom(String)
    /// Azure Maps main style
    case main
    /// Dark grey version of the Azure Maps main style
    case dark

    public var requestString: String {
        switch self {
        case let .custom(val):
            return val
        case .main:
            return "main"
        case .dark:
            return "dark"
        }
    }

    public init(_ val: String) {
        switch val.lowercased() {
        case "main":
            self = .main
        case "dark":
            self = .dark
        default:
            self = .custom(val)
        }
    }

    // MARK: Codable

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let value = try container.decode(String.self)
        self.init(value)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(requestString)
    }
}

public enum IncludeText: RequestStringConvertible, Codable, Equatable {
    /// Custom value for unrecognized enum values
    case custom(String)
    /// Include all textual data in response.
    case yes
    /// Exclude textual data from response. Only images and country names will be in response.
    case no

    public var requestString: String {
        switch self {
        case let .custom(val):
            return val
        case .yes:
            return "yes"
        case .no:
            return "no"
        }
    }

    public init(_ val: String) {
        switch val.lowercased() {
        case "yes":
            self = .yes
        case "no":
            self = .no
        default:
            self = .custom(val)
        }
    }

    // MARK: Codable

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let value = try container.decode(String.self)
        self.init(value)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(requestString)
    }
}
