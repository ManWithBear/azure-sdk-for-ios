// --------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for
// license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// --------------------------------------------------------------------------

import AzureCore
import Foundation

public enum JsonFormat: RequestStringConvertible, Codable, Equatable {
    /// Custom value for unrecognized enum values
    case custom(String)
    /// [The JavaScript Object Notation Data Interchange Format](https://tools.ietf.org/html/rfc8259)
    case json

    public var requestString: String {
        switch self {
        case let .custom(val):
            return val
        case .json:
            return "json"
        }
    }

    public init(_ val: String) {
        switch val.lowercased() {
        case "json":
            self = .json
        default:
            self = .custom(val)
        }
    }

    // MARK: Codable

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let value = try container.decode(String.self)
        self.init(value)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(requestString)
    }
}

public enum WeatherDataUnit: RequestStringConvertible, Codable, Equatable {
    /// Custom value for unrecognized enum values
    case custom(String)
    /// Return data in metric units. Some example units of metric system are Celsius and kilometer.
    case metric
    /// Return data in imperial units. Some example units of imperial system are Fahrenheit and mile.
    case imperial

    public var requestString: String {
        switch self {
        case let .custom(val):
            return val
        case .metric:
            return "metric"
        case .imperial:
            return "imperial"
        }
    }

    public init(_ val: String) {
        switch val.lowercased() {
        case "metric":
            self = .metric
        case "imperial":
            self = .imperial
        default:
            self = .custom(val)
        }
    }

    // MARK: Codable

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let value = try container.decode(String.self)
        self.init(value)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(requestString)
    }
}

/// Numeric value representing an image that displays the `iconPhrase`. Please refer to [Weather Service Concepts](https://aka.ms/AzureMapsWeatherConcepts) for details.
public enum IconCode: RequestStringConvertible, Codable, Equatable {
    /// Custom value for unrecognized enum values
    case custom(String)
    /// Sunny
    case sunny
    /// Mostly Sunny
    case mostlySunny
    /// Partly Sunny
    case partlySunny
    /// Intermittent Clouds
    case intermittentClouds
    /// Hazy Sunshine
    case hazySunshine
    /// Mostly Cloudy
    case mostlyCloudy
    /// Cloudy
    case cloudy
    /// Dreary (Overcast)
    case dreary
    /// Fog
    case fog
    /// Showers
    case showers
    /// Mostly Cloudy with Showers
    case mostlyCloudyWithShowers
    /// Partly Sunny with Showers
    case partlySunnyWithShowers
    /// Thunderstorms
    case thunderstorms
    /// Mostly Cloudy with Thunderstorms
    case mostlyCloudyWithThunderstorms
    /// Partly Sunny with Thunderstorms
    case partlySunnyWithThunderstorms
    /// Rain
    case rain
    /// Flurries
    case flurries
    /// Mostly Cloudy with Flurries
    case mostlyCloudyWithFlurries
    /// Partly Sunny with Flurries
    case partlySunnyWithFlurries
    /// Snow
    case snow
    /// Mostly Cloudy with Snow
    case mostlyCloudyWithSnow
    /// Ice
    case ice
    /// Sleet
    case sleet
    /// Freezing Rain
    case freezingRain
    /// Rain and Snow
    case rainAndSnow
    /// Hot
    case hot
    /// Cold
    case cold
    /// Windy
    case windy
    /// Clear
    case clear
    /// Mostly Clear
    case mostlyClear
    /// Partly Cloudy
    case partlyCloudy
    /// Hazy Moonlight
    case hazyMoonlight
    /// Partly Cloudy with Showers
    case partlyCloudyWithShowers
    /// Partly Cloudy with Thunderstorms
    case partlyCloudyWithThunderstorms

    public var requestString: String {
        switch self {
        case let .custom(val):
            return val
        case .sunny:
            return "1"
        case .mostlySunny:
            return "2"
        case .partlySunny:
            return "3"
        case .intermittentClouds:
            return "4"
        case .hazySunshine:
            return "5"
        case .mostlyCloudy:
            return "6"
        case .cloudy:
            return "7"
        case .dreary:
            return "8"
        case .fog:
            return "11"
        case .showers:
            return "12"
        case .mostlyCloudyWithShowers:
            return "13"
        case .partlySunnyWithShowers:
            return "14"
        case .thunderstorms:
            return "15"
        case .mostlyCloudyWithThunderstorms:
            return "16"
        case .partlySunnyWithThunderstorms:
            return "17"
        case .rain:
            return "18"
        case .flurries:
            return "19"
        case .mostlyCloudyWithFlurries:
            return "20"
        case .partlySunnyWithFlurries:
            return "21"
        case .snow:
            return "22"
        case .mostlyCloudyWithSnow:
            return "23"
        case .ice:
            return "24"
        case .sleet:
            return "25"
        case .freezingRain:
            return "26"
        case .rainAndSnow:
            return "29"
        case .hot:
            return "30"
        case .cold:
            return "31"
        case .windy:
            return "32"
        case .clear:
            return "33"
        case .mostlyClear:
            return "34"
        case .partlyCloudy:
            return "35"
        case .intermittentClouds:
            return "36"
        case .hazyMoonlight:
            return "37"
        case .partlyCloudyWithShowers:
            return "39"
        case .partlyCloudyWithThunderstorms:
            return "41"
        }
    }

    public init(_ val: String) {
        switch val.lowercased() {
        case "1":
            self = .sunny
        case "2":
            self = .mostlySunny
        case "3":
            self = .partlySunny
        case "4":
            self = .intermittentClouds
        case "5":
            self = .hazySunshine
        case "6":
            self = .mostlyCloudy
        case "7":
            self = .cloudy
        case "8":
            self = .dreary
        case "11":
            self = .fog
        case "12":
            self = .showers
        case "13":
            self = .mostlyCloudyWithShowers
        case "14":
            self = .partlySunnyWithShowers
        case "15":
            self = .thunderstorms
        case "16":
            self = .mostlyCloudyWithThunderstorms
        case "17":
            self = .partlySunnyWithThunderstorms
        case "18":
            self = .rain
        case "19":
            self = .flurries
        case "20":
            self = .mostlyCloudyWithFlurries
        case "21":
            self = .partlySunnyWithFlurries
        case "22":
            self = .snow
        case "23":
            self = .mostlyCloudyWithSnow
        case "24":
            self = .ice
        case "25":
            self = .sleet
        case "26":
            self = .freezingRain
        case "29":
            self = .rainAndSnow
        case "30":
            self = .hot
        case "31":
            self = .cold
        case "32":
            self = .windy
        case "33":
            self = .clear
        case "34":
            self = .mostlyClear
        case "35":
            self = .partlyCloudy
        case "36":
            self = .intermittentClouds
        case "37":
            self = .hazyMoonlight
        case "39":
            self = .partlyCloudyWithShowers
        case "41":
            self = .partlyCloudyWithThunderstorms
        default:
            self = .custom(val)
        }
    }

    // MARK: Codable

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let value = try container.decode(String.self)
        self.init(value)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(requestString)
    }
}

/// Numeric ID value associated with the type of unit being displayed. Can be used for unit translation. Please refer to [Weather Service Concepts](https://aka.ms/AzureMapsWeatherConcepts) for details.
public enum UnitType: RequestStringConvertible, Codable, Equatable {
    /// Custom value for unrecognized enum values
    case custom(String)
    /// feet
    case feet
    /// inches
    case inches
    /// miles
    case miles
    /// millimeter
    case millimeter
    /// centimeter
    case centimeter
    /// meter
    case meter
    /// kilometer
    case kilometer
    /// kilometersPerHour
    case kilometersPerHour
    /// knots
    case knots
    /// milesPerHour
    case milesPerHour
    /// metersPerSecond
    case metersPerSecond
    /// hectoPascals
    case hectoPascals
    /// inchesOfMercury
    case inchesOfMercury
    /// kiloPascals
    case kiloPascals
    /// millibars
    case millibars
    /// millimetersOfMercury
    case millimetersOfMercury
    /// poundsPerSquareInch
    case poundsPerSquareInch
    /// celsius
    case celsius
    /// fahrenheit
    case fahrenheit
    /// kelvin
    case kelvin
    /// percent
    case percent
    /// float
    case float
    /// integer
    case integer
    /// MicrogramsPerCubicMeterOfAir
    case microgramsPerCubicMeterOfAir

    public var requestString: String {
        switch self {
        case let .custom(val):
            return val
        case .feet:
            return "0"
        case .inches:
            return "1"
        case .miles:
            return "2"
        case .millimeter:
            return "3"
        case .centimeter:
            return "4"
        case .meter:
            return "5"
        case .kilometer:
            return "6"
        case .kilometersPerHour:
            return "7"
        case .knots:
            return "8"
        case .milesPerHour:
            return "9"
        case .metersPerSecond:
            return "10"
        case .hectoPascals:
            return "11"
        case .inchesOfMercury:
            return "12"
        case .kiloPascals:
            return "13"
        case .millibars:
            return "14"
        case .millimetersOfMercury:
            return "15"
        case .poundsPerSquareInch:
            return "16"
        case .celsius:
            return "17"
        case .fahrenheit:
            return "18"
        case .kelvin:
            return "19"
        case .percent:
            return "20"
        case .float:
            return "21"
        case .integer:
            return "22"
        case .microgramsPerCubicMeterOfAir:
            return "31"
        }
    }

    public init(_ val: String) {
        switch val.lowercased() {
        case "0":
            self = .feet
        case "1":
            self = .inches
        case "2":
            self = .miles
        case "3":
            self = .millimeter
        case "4":
            self = .centimeter
        case "5":
            self = .meter
        case "6":
            self = .kilometer
        case "7":
            self = .kilometersPerHour
        case "8":
            self = .knots
        case "9":
            self = .milesPerHour
        case "10":
            self = .metersPerSecond
        case "11":
            self = .hectoPascals
        case "12":
            self = .inchesOfMercury
        case "13":
            self = .kiloPascals
        case "14":
            self = .millibars
        case "15":
            self = .millimetersOfMercury
        case "16":
            self = .poundsPerSquareInch
        case "17":
            self = .celsius
        case "18":
            self = .fahrenheit
        case "19":
            self = .kelvin
        case "20":
            self = .percent
        case "21":
            self = .float
        case "22":
            self = .integer
        case "31":
            self = .microgramsPerCubicMeterOfAir
        default:
            self = .custom(val)
        }
    }

    // MARK: Codable

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let value = try container.decode(String.self)
        self.init(value)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(requestString)
    }
}

/// Specifies the type of precipitation ("Rain" "Snow" "Ice" or "Mix"). If dbz is zero, precipitationType is not present in the response.
public enum PrecipitationType: RequestStringConvertible, Codable, Equatable {
    /// Custom value for unrecognized enum values
    case custom(String)
    /// Rain
    case rain
    /// Snow
    case snow
    /// Ice
    case ice
    /// Mix
    case mix

    public var requestString: String {
        switch self {
        case let .custom(val):
            return val
        case .rain:
            return "Rain"
        case .snow:
            return "Snow"
        case .ice:
            return "Ice"
        case .mix:
            return "Mix"
        }
    }

    public init(_ val: String) {
        switch val.lowercased() {
        case "rain":
            self = .rain
        case "snow":
            self = .snow
        case "ice":
            self = .ice
        case "mix":
            self = .mix
        default:
            self = .custom(val)
        }
    }

    // MARK: Codable

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let value = try container.decode(String.self)
        self.init(value)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(requestString)
    }
}

/// Quarter of the day.
public enum DayQuarter: RequestStringConvertible, Codable, Equatable {
    /// Custom value for unrecognized enum values
    case custom(String)
    /// 7:00 am - 1:00 pm / 7:00- 13:00
    case firstQuarter
    /// 1:00 pm - 7:00 pm/ 13:00- 19:00
    case secondQuarter
    /// 7:00 pm - 1:00 am/ 19:00 - 01:00
    case thirdQuarter
    /// 1:00 am - 7:00 am/ 01:00 - 07:00
    case forthQuarter

    public var requestString: String {
        switch self {
        case let .custom(val):
            return val
        case .firstQuarter:
            return "0"
        case .secondQuarter:
            return "1"
        case .thirdQuarter:
            return "2"
        case .forthQuarter:
            return "3"
        }
    }

    public init(_ val: String) {
        switch val.lowercased() {
        case "0":
            self = .firstQuarter
        case "1":
            self = .secondQuarter
        case "2":
            self = .thirdQuarter
        case "3":
            self = .forthQuarter
        default:
            self = .custom(val)
        }
    }

    // MARK: Codable

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let value = try container.decode(String.self)
        self.init(value)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(requestString)
    }
}

/// A severity/hazard index.
///   * `0` - No hazard.
///   * `1` - Be informed, be aware.
///   * `2` - Pay attention, be prepared.
///   * `3` - Take action.
///   * `4` - Life threatening, emergency.
public enum HazardIndex: RequestStringConvertible, Codable, Equatable {
    /// Custom value for unrecognized enum values
    case custom(String)
    /// No hazard
    case noHazard
    /// Be informed
    case informed
    /// Pay attention
    case payAttention
    /// Take action
    case takeAction
    /// Emergency
    case emergency

    public var requestString: String {
        switch self {
        case let .custom(val):
            return val
        case .noHazard:
            return "0"
        case .informed:
            return "1"
        case .payAttention:
            return "2"
        case .takeAction:
            return "3"
        case .emergency:
            return "4"
        }
    }

    public init(_ val: String) {
        switch val.lowercased() {
        case "0":
            self = .noHazard
        case "1":
            self = .informed
        case "2":
            self = .payAttention
        case "3":
            self = .takeAction
        case "4":
            self = .emergency
        default:
            self = .custom(val)
        }
    }

    // MARK: Codable

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let value = try container.decode(String.self)
        self.init(value)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(requestString)
    }
}

/// Keyword for the latest status of the alert.
public enum LatestStatusKeyword: RequestStringConvertible, Codable, Equatable {
    /// Custom value for unrecognized enum values
    case custom(String)
    /// "New" - the status of an alert upon initial issuance.
    case new
    /// "Extend" - the alert has been extended in time, in area, or both since its initial issuance.
    case extend
    /// "Cancel" - the alert has been canceled prior to its original expiration time.
    case cancel
    /// "Correct" - the alert has been modified to correct a previous error.
    case correct
    /// "Expire" - the alert has expired and is no longer active.
    case expire
    /// "Upgrade" - the alert has been upgraded to a higher class or category since its initial issuance.
    case upgrade
    /// "Continue" - the alert has been updated since its initial issuance, but no changes were made to `alertDetails`, `startTime`, `endTime`, or `class`.
    case `continue`
    /// "Update" - the alert has been updated since its initial issuance.
    case update

    public var requestString: String {
        switch self {
        case let .custom(val):
            return val
        case .new:
            return "New"
        case .extend:
            return "Extend"
        case .cancel:
            return "Cancel"
        case .correct:
            return "Correct"
        case .expire:
            return "Expire"
        case .upgrade:
            return "Upgrade"
        case .continue:
            return "Continue"
        case .update:
            return "Update"
        }
    }

    public init(_ val: String) {
        switch val.lowercased() {
        case "new":
            self = .new
        case "extend":
            self = .extend
        case "cancel":
            self = .cancel
        case "correct":
            self = .correct
        case "expire":
            self = .expire
        case "upgrade":
            self = .upgrade
        case "continue":
            self = .continue
        case "update":
            self = .update
        default:
            self = .custom(val)
        }
    }

    // MARK: Codable

    public init(from decoder: Decoder) throws {
        let container = try decoder.singleValueContainer()
        let value = try container.decode(String.self)
        self.init(value)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode(requestString)
    }
}
