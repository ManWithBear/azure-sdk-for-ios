// --------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for
// license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// --------------------------------------------------------------------------

import AzureCore
import Foundation
// swiftlint:disable superfluous_disable_command
// swiftlint:disable identifier_name
// swiftlint:disable line_length
// swiftlint:disable cyclomatic_complexity

public struct ForecastInterval: Codable {
    // MARK: Properties

    /// The date and time for the start of the interval in ISO 8601 format, for example, 2019-10-27T19:39:57-08:00.
    public let startTime: Iso8601Date?
    /// The first minute for the interval.
    public let minute: Int32?
    /// A unit that represents forecasted precipitation intensity.
    public let decibelRelativeToZ: Double?
    /// A short phrase describing precipitation condition for the interval.
    public let shortDescription: String?
    /// Key that specifies the threshold value. Along with precipitationType, can be used to determine the simplifiedColor. If dbz is zero, not present in the response.
    public let threshold: String?
    /// The full spectrum color that maps to the dBZ (decibel relative to Z). If dbz is zero, color is not present in the response.
    public let color: ColorValue?
    /// The band color that maps to the precipitation type and threshold. If dbz is zero, not present in the response.
    public let simplifiedColor: ColorValue?
    /// Specifies the type of precipitation ("Rain" "Snow" "Ice" or "Mix"). If dbz is zero, precipitationType is not present in the response.
    public let precipitationType: PrecipitationType?
    /// Numeric value representing an image that displays the `iconPhrase`. Please refer to [Weather Service Concepts](https://aka.ms/AzureMapsWeatherConcepts) for details.
    public let iconCode: IconCode?
    /// Percent representing cloud cover.
    public let cloudCover: Int32?

    // MARK: Initializers

    /// Initialize a `ForecastInterval` structure.
    /// - Parameters:
    ///   - startTime: The date and time for the start of the interval in ISO 8601 format, for example, 2019-10-27T19:39:57-08:00.
    ///   - minute: The first minute for the interval.
    ///   - decibelRelativeToZ: A unit that represents forecasted precipitation intensity.
    ///   - shortDescription: A short phrase describing precipitation condition for the interval.
    ///   - threshold: Key that specifies the threshold value. Along with precipitationType, can be used to determine the simplifiedColor. If dbz is zero, not present in the response.
    ///   - color: The full spectrum color that maps to the dBZ (decibel relative to Z). If dbz is zero, color is not present in the response.
    ///   - simplifiedColor: The band color that maps to the precipitation type and threshold. If dbz is zero, not present in the response.
    ///   - precipitationType: Specifies the type of precipitation ("Rain" "Snow" "Ice" or "Mix"). If dbz is zero, precipitationType is not present in the response.
    ///   - iconCode: Numeric value representing an image that displays the `iconPhrase`. Please refer to [Weather Service Concepts](https://aka.ms/AzureMapsWeatherConcepts) for details.
    ///   - cloudCover: Percent representing cloud cover.
    public init(
        startTime: Iso8601Date? = nil, minute: Int32? = nil, decibelRelativeToZ: Double? = nil,
        shortDescription: String? = nil, threshold: String? = nil, color: ColorValue? = nil,
        simplifiedColor: ColorValue? = nil, precipitationType: PrecipitationType? = nil, iconCode: IconCode? = nil,
        cloudCover: Int32? = nil
    ) {
        self.startTime = startTime
        self.minute = minute
        self.decibelRelativeToZ = decibelRelativeToZ
        self.shortDescription = shortDescription
        self.threshold = threshold
        self.color = color
        self.simplifiedColor = simplifiedColor
        self.precipitationType = precipitationType
        self.iconCode = iconCode
        self.cloudCover = cloudCover
    }

    // MARK: Codable

    enum CodingKeys: String, CodingKey {
        case startTime = "startTime"
        case minute = "minute"
        case decibelRelativeToZ = "dbz"
        case shortDescription = "shortPhrase"
        case threshold = "threshold"
        case color = "color"
        case simplifiedColor = "simplifiedColor"
        case precipitationType = "precipitationType"
        case iconCode = "iconCode"
        case cloudCover = "cloudCover"
    }

    /// Initialize a `ForecastInterval` structure from decoder
    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.startTime = try? container.decode(Iso8601Date.self, forKey: .startTime)
        self.minute = try? container.decode(Int32.self, forKey: .minute)
        self.decibelRelativeToZ = try? container.decode(Double.self, forKey: .decibelRelativeToZ)
        self.shortDescription = try? container.decode(String.self, forKey: .shortDescription)
        self.threshold = try? container.decode(String.self, forKey: .threshold)
        self.color = try? container.decode(ColorValue.self, forKey: .color)
        self.simplifiedColor = try? container.decode(ColorValue.self, forKey: .simplifiedColor)
        self.precipitationType = try? container.decode(PrecipitationType.self, forKey: .precipitationType)
        self.iconCode = try? container.decode(IconCode.self, forKey: .iconCode)
        self.cloudCover = try? container.decode(Int32.self, forKey: .cloudCover)
    }

    /// Encode a `ForecastInterval` structure
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        if startTime != nil { try? container.encode(startTime, forKey: .startTime) }
        if minute != nil { try? container.encode(minute, forKey: .minute) }
        if decibelRelativeToZ != nil { try? container.encode(decibelRelativeToZ, forKey: .decibelRelativeToZ) }
        if shortDescription != nil { try? container.encode(shortDescription, forKey: .shortDescription) }
        if threshold != nil { try? container.encode(threshold, forKey: .threshold) }
        if color != nil { try? container.encode(color, forKey: .color) }
        if simplifiedColor != nil { try? container.encode(simplifiedColor, forKey: .simplifiedColor) }
        if precipitationType != nil { try? container.encode(precipitationType, forKey: .precipitationType) }
        if iconCode != nil { try? container.encode(iconCode, forKey: .iconCode) }
        if cloudCover != nil { try? container.encode(cloudCover, forKey: .cloudCover) }
    }
}
