// --------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for
// license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// --------------------------------------------------------------------------

import AzureCore
import Foundation
// swiftlint:disable superfluous_disable_command
// swiftlint:disable identifier_name
// swiftlint:disable line_length
// swiftlint:disable cyclomatic_complexity

public struct DailyForecastDetail: Codable {
    // MARK: Properties

    /// Numeric value representing an image that displays the `iconPhrase`. Please refer to [Weather Service Concepts](https://aka.ms/AzureMapsWeatherConcepts) for details.
    public let iconCode: IconCode?
    /// Phrase description of the icon. Displayed in specified language. For example, 'Sunny'.
    public let iconPhrase: String?
    /// Local weather data provider information.
    public let localSource: LocalSource?
    /// Indicates the presence or absence of precipitation. True indicates the presence of precipitation, false indicates the absence of precipitation.
    public let hasPrecipitation: Bool?
    /// Specifies the type of precipitation ("Rain" "Snow" "Ice" or "Mix"). If dbz is zero, precipitationType is not present in the response.
    public let precipitationType: PrecipitationType?
    /// Description of the intensity.
    public let precipitationIntensity: String?
    /// Phrase description of the forecast in specified language. Azure Maps attempts to keep this phrase under 30 characters in length, but some languages/weather events may result in a longer phrase length, exceeding 30 characters.
    public let shortDescription: String?
    /// Phrase description of the forecast in specified language. Azure Maps attempts to keep this phrase under 100 characters in length, but some languages/weather events may result in a longer phrase length, exceeding 100 characters.
    public let longPhrase: String?
    /// Percent representing the probability of precipitation. For example, '20'.
    public let precipitationProbability: Int32?
    /// Percent representing the probability of a thunderstorm. For example, '80'.
    public let thunderstormProbability: Int32?
    /// Percent representing the probability of rain. For example, '40'.
    public let rainProbability: Int32?
    /// Percent representing the probability of snow. For example, '30'.
    public let snowProbability: Int32?
    /// Percent representing the probability of ice. For example, '30'.
    public let iceProbability: Int32?
    /// Wind details being returned including speed and direction.
    public let wind: WindDetails?
    /// Wind gust. Wind gust is a sudden, brief increase in speed of the wind.
    public let windGust: WindDetails?
    /// Total liquid equivalent of precipitation during the forecast period.
    public let totalLiquid: WeatherValue?
    /// Rain
    public let rain: WeatherValue?
    /// Snow
    public let snow: WeatherValue?
    /// Ice
    public let ice: WeatherValue?
    /// Hours of precipitation
    public let hoursOfPrecipitation: Float?
    /// Hours of rain.
    public let hoursOfRain: Float?
    /// Hours of snow.
    public let hoursOfSnow: Float?
    /// Hours of ice.
    public let hoursOfIce: Float?
    /// Percent representing cloud cover.
    public let cloudCover: Int32?

    // MARK: Initializers

    /// Initialize a `DailyForecastDetail` structure.
    /// - Parameters:
    ///   - iconCode: Numeric value representing an image that displays the `iconPhrase`. Please refer to [Weather Service Concepts](https://aka.ms/AzureMapsWeatherConcepts) for details.
    ///   - iconPhrase: Phrase description of the icon. Displayed in specified language. For example, 'Sunny'.
    ///   - localSource: Local weather data provider information.
    ///   - hasPrecipitation: Indicates the presence or absence of precipitation. True indicates the presence of precipitation, false indicates the absence of precipitation.
    ///   - precipitationType: Specifies the type of precipitation ("Rain" "Snow" "Ice" or "Mix"). If dbz is zero, precipitationType is not present in the response.
    ///   - precipitationIntensity: Description of the intensity.
    ///   - shortDescription: Phrase description of the forecast in specified language. Azure Maps attempts to keep this phrase under 30 characters in length, but some languages/weather events may result in a longer phrase length, exceeding 30 characters.
    ///   - longPhrase: Phrase description of the forecast in specified language. Azure Maps attempts to keep this phrase under 100 characters in length, but some languages/weather events may result in a longer phrase length, exceeding 100 characters.
    ///   - precipitationProbability: Percent representing the probability of precipitation. For example, '20'.
    ///   - thunderstormProbability: Percent representing the probability of a thunderstorm. For example, '80'.
    ///   - rainProbability: Percent representing the probability of rain. For example, '40'.
    ///   - snowProbability: Percent representing the probability of snow. For example, '30'.
    ///   - iceProbability: Percent representing the probability of ice. For example, '30'.
    ///   - wind: Wind details being returned including speed and direction.
    ///   - windGust: Wind gust. Wind gust is a sudden, brief increase in speed of the wind.
    ///   - totalLiquid: Total liquid equivalent of precipitation during the forecast period.
    ///   - rain: Rain
    ///   - snow: Snow
    ///   - ice: Ice
    ///   - hoursOfPrecipitation: Hours of precipitation
    ///   - hoursOfRain: Hours of rain.
    ///   - hoursOfSnow: Hours of snow.
    ///   - hoursOfIce: Hours of ice.
    ///   - cloudCover: Percent representing cloud cover.
    public init(
        iconCode: IconCode? = nil, iconPhrase: String? = nil, localSource: LocalSource? = nil,
        hasPrecipitation: Bool? = nil,
        precipitationType: PrecipitationType? = nil, precipitationIntensity: String? = nil,
        shortDescription: String? = nil, longPhrase: String? = nil, precipitationProbability: Int32? = nil,
        thunderstormProbability: Int32? = nil, rainProbability: Int32? = nil, snowProbability: Int32? = nil,
        iceProbability: Int32? = nil, wind: WindDetails? = nil, windGust: WindDetails? = nil,
        totalLiquid: WeatherValue? = nil, rain: WeatherValue? = nil, snow: WeatherValue? = nil,
        ice: WeatherValue? = nil,
        hoursOfPrecipitation: Float? = nil, hoursOfRain: Float? = nil, hoursOfSnow: Float? = nil,
        hoursOfIce: Float? = nil, cloudCover: Int32? = nil
    ) {
        self.iconCode = iconCode
        self.iconPhrase = iconPhrase
        self.localSource = localSource
        self.hasPrecipitation = hasPrecipitation
        self.precipitationType = precipitationType
        self.precipitationIntensity = precipitationIntensity
        self.shortDescription = shortDescription
        self.longPhrase = longPhrase
        self.precipitationProbability = precipitationProbability
        self.thunderstormProbability = thunderstormProbability
        self.rainProbability = rainProbability
        self.snowProbability = snowProbability
        self.iceProbability = iceProbability
        self.wind = wind
        self.windGust = windGust
        self.totalLiquid = totalLiquid
        self.rain = rain
        self.snow = snow
        self.ice = ice
        self.hoursOfPrecipitation = hoursOfPrecipitation
        self.hoursOfRain = hoursOfRain
        self.hoursOfSnow = hoursOfSnow
        self.hoursOfIce = hoursOfIce
        self.cloudCover = cloudCover
    }

    // MARK: Codable

    enum CodingKeys: String, CodingKey {
        case iconCode = "iconCode"
        case iconPhrase = "iconPhrase"
        case localSource = "localSource"
        case hasPrecipitation = "hasPrecipitation"
        case precipitationType = "precipitationType"
        case precipitationIntensity = "precipitationIntensity"
        case shortDescription = "shortPhrase"
        case longPhrase = "longPhrase"
        case precipitationProbability = "precipitationProbability"
        case thunderstormProbability = "thunderstormProbability"
        case rainProbability = "rainProbability"
        case snowProbability = "snowProbability"
        case iceProbability = "iceProbability"
        case wind = "wind"
        case windGust = "windGust"
        case totalLiquid = "totalLiquid"
        case rain = "rain"
        case snow = "snow"
        case ice = "ice"
        case hoursOfPrecipitation = "hoursOfPrecipitation"
        case hoursOfRain = "hoursOfRain"
        case hoursOfSnow = "hoursOfSnow"
        case hoursOfIce = "hoursOfIce"
        case cloudCover = "cloudCover"
    }

    /// Initialize a `DailyForecastDetail` structure from decoder
    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.iconCode = try? container.decode(IconCode.self, forKey: .iconCode)
        self.iconPhrase = try? container.decode(String.self, forKey: .iconPhrase)
        self.localSource = try? container.decode(LocalSource.self, forKey: .localSource)
        self.hasPrecipitation = try? container.decode(Bool.self, forKey: .hasPrecipitation)
        self.precipitationType = try? container.decode(PrecipitationType.self, forKey: .precipitationType)
        self.precipitationIntensity = try? container.decode(String.self, forKey: .precipitationIntensity)
        self.shortDescription = try? container.decode(String.self, forKey: .shortDescription)
        self.longPhrase = try? container.decode(String.self, forKey: .longPhrase)
        self.precipitationProbability = try? container.decode(Int32.self, forKey: .precipitationProbability)
        self.thunderstormProbability = try? container.decode(Int32.self, forKey: .thunderstormProbability)
        self.rainProbability = try? container.decode(Int32.self, forKey: .rainProbability)
        self.snowProbability = try? container.decode(Int32.self, forKey: .snowProbability)
        self.iceProbability = try? container.decode(Int32.self, forKey: .iceProbability)
        self.wind = try? container.decode(WindDetails.self, forKey: .wind)
        self.windGust = try? container.decode(WindDetails.self, forKey: .windGust)
        self.totalLiquid = try? container.decode(WeatherValue.self, forKey: .totalLiquid)
        self.rain = try? container.decode(WeatherValue.self, forKey: .rain)
        self.snow = try? container.decode(WeatherValue.self, forKey: .snow)
        self.ice = try? container.decode(WeatherValue.self, forKey: .ice)
        self.hoursOfPrecipitation = try? container.decode(Float.self, forKey: .hoursOfPrecipitation)
        self.hoursOfRain = try? container.decode(Float.self, forKey: .hoursOfRain)
        self.hoursOfSnow = try? container.decode(Float.self, forKey: .hoursOfSnow)
        self.hoursOfIce = try? container.decode(Float.self, forKey: .hoursOfIce)
        self.cloudCover = try? container.decode(Int32.self, forKey: .cloudCover)
    }

    /// Encode a `DailyForecastDetail` structure
    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        if iconCode != nil { try? container.encode(iconCode, forKey: .iconCode) }
        if iconPhrase != nil { try? container.encode(iconPhrase, forKey: .iconPhrase) }
        if localSource != nil { try? container.encode(localSource, forKey: .localSource) }
        if hasPrecipitation != nil { try? container.encode(hasPrecipitation, forKey: .hasPrecipitation) }
        if precipitationType != nil { try? container.encode(precipitationType, forKey: .precipitationType) }
        if precipitationIntensity !=
            nil { try? container.encode(precipitationIntensity, forKey: .precipitationIntensity) }
        if shortDescription != nil { try? container.encode(shortDescription, forKey: .shortDescription) }
        if longPhrase != nil { try? container.encode(longPhrase, forKey: .longPhrase) }
        if precipitationProbability !=
            nil { try? container.encode(precipitationProbability, forKey: .precipitationProbability) }
        if thunderstormProbability !=
            nil { try? container.encode(thunderstormProbability, forKey: .thunderstormProbability) }
        if rainProbability != nil { try? container.encode(rainProbability, forKey: .rainProbability) }
        if snowProbability != nil { try? container.encode(snowProbability, forKey: .snowProbability) }
        if iceProbability != nil { try? container.encode(iceProbability, forKey: .iceProbability) }
        if wind != nil { try? container.encode(wind, forKey: .wind) }
        if windGust != nil { try? container.encode(windGust, forKey: .windGust) }
        if totalLiquid != nil { try? container.encode(totalLiquid, forKey: .totalLiquid) }
        if rain != nil { try? container.encode(rain, forKey: .rain) }
        if snow != nil { try? container.encode(snow, forKey: .snow) }
        if ice != nil { try? container.encode(ice, forKey: .ice) }
        if hoursOfPrecipitation != nil { try? container.encode(hoursOfPrecipitation, forKey: .hoursOfPrecipitation) }
        if hoursOfRain != nil { try? container.encode(hoursOfRain, forKey: .hoursOfRain) }
        if hoursOfSnow != nil { try? container.encode(hoursOfSnow, forKey: .hoursOfSnow) }
        if hoursOfIce != nil { try? container.encode(hoursOfIce, forKey: .hoursOfIce) }
        if cloudCover != nil { try? container.encode(cloudCover, forKey: .cloudCover) }
    }
}
