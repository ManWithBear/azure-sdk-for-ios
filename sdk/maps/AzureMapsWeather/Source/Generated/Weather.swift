// --------------------------------------------------------------------------
// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for
// license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// --------------------------------------------------------------------------

import AzureCore
import Foundation
// swiftlint:disable superfluous_disable_command
// swiftlint:disable file_length
// swiftlint:disable cyclomatic_complexity
// swiftlint:disable function_body_length
// swiftlint:disable type_body_length

internal final class Weather {
    internal let client: WeatherClientInternal

    init(client: WeatherClientInternal) {
        self.client = client
    }

    /// **Get Hourly Forecast**
    /// **Applies to**: S0 and S1 pricing tiers.
    /// Request detailed weather forecast by the hour for the next 1, 12, 24 (1 day), 72 (3 days), 120 (5 days), and 240 hours (10 days) for the given the given coordinate location.  The API returns details such as temperature, humidity, wind, precipitation, and ultraviolet (UV) index.
    /// In S0 you can request hourly forecast for the next 1, 12, 24 hours (1 day), and 72 hours (3 days). In S1 you can also request hourly forecast for the next 120 (5 days) and 240 hours (10 days).
    /// - Parameters:
    ///    - format : Desired format of the response. Only `json` format is supported.
    ///    - coordinates : The applicable query specified as a comma separated string composed by latitude followed by longitude e.g. "47.641268,-122.125679".
    ///    - options: A list of options for the operation
    ///    - completionHandler: A completion handler that receives a status code on
    ///     success.
    internal func getHourlyForecast(
        format: JsonFormat,
        coordinates: [Double],
        withOptions options: GetHourlyForecastOptions? = nil,
        completionHandler: @escaping HTTPResultHandler<HourlyForecastResponse>
    ) {
        let dispatchQueue = options?.dispatchQueue ?? client.commonOptions.dispatchQueue ?? DispatchQueue.main

        // Create request parameters
        let params = RequestParameters(
            (.path, "format", format, .encode),
            (.query, "query", coordinates.map { "\($0)" }.joined(separator: ","), .encode),
            (.query, "unit", options?.unit, .encode), (.query, "duration", options?.duration, .encode),
            (.query, "language", options?.language, .encode),
            (.uri, "$host", client.endpoint.absoluteString, .skipEncoding),
            (.header, "x-ms-client-id", client.clientId, .encode),
            (.query, "api-version", client.options.apiVersion, .encode),
            (.header, "Accept", "application/json", .encode)
        )

        // Construct request
        let urlTemplate = "/weather/forecast/hourly/{format}"
        guard let requestUrl = client.url(host: "{$host}", template: urlTemplate, params: params),
            let request = try? HTTPRequest(method: .get, url: requestUrl, headers: params.headers)
        else {
            client.options.logger.error("Failed to construct HTTP request.")
            return
        }

        // Apply client-side validation
        var validationErrors = [String]()
        // Validate coordinates
        if coordinates.count > 2 {
            validationErrors.append("coordinates: maxItems 2")
        }
        if coordinates.count < 2 {
            validationErrors.append("coordinates: minItems 2")
        }
        if !validationErrors.isEmpty {
            dispatchQueue.async {
                let error = AzureError.client("Validation Errors: \(validationErrors.joined(separator: ", "))")
                completionHandler(.failure(error), nil)
            }
            return
        }

        // Send request
        let context = PipelineContext.of(keyValues: [
            ContextKey.allowedStatusCodes.rawValue: [200] as AnyObject
        ])
        context.add(cancellationToken: options?.cancellationToken, applying: client.options)
        context.merge(with: options?.context)
        client.request(request, context: context) { result, httpResponse in
            guard let data = httpResponse?.data else {
                let noDataError = AzureError.client("Response data expected but not found.")
                dispatchQueue.async {
                    completionHandler(.failure(noDataError), httpResponse)
                }
                return
            }
            switch result {
            case .success:
                guard let statusCode = httpResponse?.statusCode else {
                    let noStatusCodeError = AzureError.client("Expected a status code in response but didn't find one.")
                    dispatchQueue.async {
                        completionHandler(.failure(noStatusCodeError), httpResponse)
                    }
                    return
                }
                if [
                    200
                ].contains(statusCode) {
                    do {
                        let decoder = JSONDecoder()
                        let decoded = try decoder.decode(HourlyForecastResponse.self, from: data)
                        dispatchQueue.async {
                            completionHandler(.success(decoded), httpResponse)
                        }
                    } catch {
                        dispatchQueue.async {
                            completionHandler(.failure(AzureError.client("Decoding error.", error)), httpResponse)
                        }
                    }
                }
            case .failure:
                do {
                    let decoder = JSONDecoder()
                    let decoded = try decoder.decode(ErrorResponse.self, from: data)
                    dispatchQueue.async {
                        completionHandler(
                            .failure(AzureError.service("An unexpected error occurred.", decoded)),
                            httpResponse
                        )
                    }
                } catch {
                    dispatchQueue.async {
                        completionHandler(.failure(AzureError.client("Decoding error.", error)), httpResponse)
                    }
                }
            }
        }
    }

    /// **Get Minute Forecast**
    ///
    ///
    /// **Applies to**: S1 pricing tier.
    /// Get Minute Forecast service returns minute-by-minute forecasts for a given location for the next 120 minutes.  Users can request weather forecasts in the interval of 1, 5 and 15 minutes.  The response will include details such as the type of precipitation (including rain, snow, or a mixture of both), start time, and precipitation intensity value (dBZ).
    /// - Parameters:
    ///    - format : Desired format of the response. Only `json` format is supported.
    ///    - coordinates : The applicable query specified as a comma separated string composed by latitude followed by longitude e.g. "47.641268,-122.125679".
    ///    - options: A list of options for the operation
    ///    - completionHandler: A completion handler that receives a status code on
    ///     success.
    internal func getMinuteForecast(
        format: JsonFormat,
        coordinates: [Double],
        withOptions options: GetMinuteForecastOptions? = nil,
        completionHandler: @escaping HTTPResultHandler<MinuteForecastResponse>
    ) {
        let dispatchQueue = options?.dispatchQueue ?? client.commonOptions.dispatchQueue ?? DispatchQueue.main

        // Create request parameters
        let params = RequestParameters(
            (.path, "format", format, .encode),
            (.query, "query", coordinates.map { "\($0)" }.joined(separator: ","), .encode),
            (.query, "interval", options?.interval, .encode), (.query, "language", options?.language, .encode),
            (.uri, "$host", client.endpoint.absoluteString, .skipEncoding),
            (.header, "x-ms-client-id", client.clientId, .encode),
            (.query, "api-version", client.options.apiVersion, .encode),
            (.header, "Accept", "application/json", .encode)
        )

        // Construct request
        let urlTemplate = "/weather/forecast/minute/{format}"
        guard let requestUrl = client.url(host: "{$host}", template: urlTemplate, params: params),
            let request = try? HTTPRequest(method: .get, url: requestUrl, headers: params.headers)
        else {
            client.options.logger.error("Failed to construct HTTP request.")
            return
        }

        // Apply client-side validation
        var validationErrors = [String]()
        // Validate coordinates
        if coordinates.count > 2 {
            validationErrors.append("coordinates: maxItems 2")
        }
        if coordinates.count < 2 {
            validationErrors.append("coordinates: minItems 2")
        }
        if !validationErrors.isEmpty {
            dispatchQueue.async {
                let error = AzureError.client("Validation Errors: \(validationErrors.joined(separator: ", "))")
                completionHandler(.failure(error), nil)
            }
            return
        }

        // Send request
        let context = PipelineContext.of(keyValues: [
            ContextKey.allowedStatusCodes.rawValue: [200] as AnyObject
        ])
        context.add(cancellationToken: options?.cancellationToken, applying: client.options)
        context.merge(with: options?.context)
        client.request(request, context: context) { result, httpResponse in
            guard let data = httpResponse?.data else {
                let noDataError = AzureError.client("Response data expected but not found.")
                dispatchQueue.async {
                    completionHandler(.failure(noDataError), httpResponse)
                }
                return
            }
            switch result {
            case .success:
                guard let statusCode = httpResponse?.statusCode else {
                    let noStatusCodeError = AzureError.client("Expected a status code in response but didn't find one.")
                    dispatchQueue.async {
                        completionHandler(.failure(noStatusCodeError), httpResponse)
                    }
                    return
                }
                if [
                    200
                ].contains(statusCode) {
                    do {
                        let decoder = JSONDecoder()
                        let decoded = try decoder.decode(MinuteForecastResponse.self, from: data)
                        dispatchQueue.async {
                            completionHandler(.success(decoded), httpResponse)
                        }
                    } catch {
                        dispatchQueue.async {
                            completionHandler(.failure(AzureError.client("Decoding error.", error)), httpResponse)
                        }
                    }
                }
            case .failure:
                do {
                    let decoder = JSONDecoder()
                    let decoded = try decoder.decode(ErrorResponse.self, from: data)
                    dispatchQueue.async {
                        completionHandler(
                            .failure(AzureError.service("An unexpected error occurred.", decoded)),
                            httpResponse
                        )
                    }
                } catch {
                    dispatchQueue.async {
                        completionHandler(.failure(AzureError.client("Decoding error.", error)), httpResponse)
                    }
                }
            }
        }
    }

    /// **Get Quarter-Day Forecast**
    ///
    ///
    /// **Applies to**: S0 and S1 pricing tiers.
    /// Service returns detailed weather forecast by quarter-day for the next 1, 5, 10, or 15 days for a given location. Response data is presented by quarters of the day - morning, afternoon, evening, and overnight. Details such as temperature, humidity, wind, precipitation, and UV index are returned.
    /// - Parameters:
    ///    - format : Desired format of the response. Only `json` format is supported.
    ///    - coordinates : The applicable query specified as a comma separated string composed by latitude followed by longitude e.g. "47.641268,-122.125679".
    ///    - options: A list of options for the operation
    ///    - completionHandler: A completion handler that receives a status code on
    ///     success.
    internal func getQuarterDayForecast(
        format: JsonFormat,
        coordinates: [Double],
        withOptions options: GetQuarterDayForecastOptions? = nil,
        completionHandler: @escaping HTTPResultHandler<QuarterDayForecastResponse>
    ) {
        let dispatchQueue = options?.dispatchQueue ?? client.commonOptions.dispatchQueue ?? DispatchQueue.main

        // Create request parameters
        let params = RequestParameters(
            (.path, "format", format, .encode),
            (.query, "query", coordinates.map { "\($0)" }.joined(separator: ","), .encode),
            (.query, "unit", options?.unit, .encode), (.query, "duration", options?.duration, .encode),
            (.query, "language", options?.language, .encode),
            (.uri, "$host", client.endpoint.absoluteString, .skipEncoding),
            (.header, "x-ms-client-id", client.clientId, .encode),
            (.query, "api-version", client.options.apiVersion, .encode),
            (.header, "Accept", "application/json", .encode)
        )

        // Construct request
        let urlTemplate = "/weather/forecast/quarterDay/{format}"
        guard let requestUrl = client.url(host: "{$host}", template: urlTemplate, params: params),
            let request = try? HTTPRequest(method: .get, url: requestUrl, headers: params.headers)
        else {
            client.options.logger.error("Failed to construct HTTP request.")
            return
        }

        // Apply client-side validation
        var validationErrors = [String]()
        // Validate coordinates
        if coordinates.count > 2 {
            validationErrors.append("coordinates: maxItems 2")
        }
        if coordinates.count < 2 {
            validationErrors.append("coordinates: minItems 2")
        }
        if !validationErrors.isEmpty {
            dispatchQueue.async {
                let error = AzureError.client("Validation Errors: \(validationErrors.joined(separator: ", "))")
                completionHandler(.failure(error), nil)
            }
            return
        }

        // Send request
        let context = PipelineContext.of(keyValues: [
            ContextKey.allowedStatusCodes.rawValue: [200] as AnyObject
        ])
        context.add(cancellationToken: options?.cancellationToken, applying: client.options)
        context.merge(with: options?.context)
        client.request(request, context: context) { result, httpResponse in
            guard let data = httpResponse?.data else {
                let noDataError = AzureError.client("Response data expected but not found.")
                dispatchQueue.async {
                    completionHandler(.failure(noDataError), httpResponse)
                }
                return
            }
            switch result {
            case .success:
                guard let statusCode = httpResponse?.statusCode else {
                    let noStatusCodeError = AzureError.client("Expected a status code in response but didn't find one.")
                    dispatchQueue.async {
                        completionHandler(.failure(noStatusCodeError), httpResponse)
                    }
                    return
                }
                if [
                    200
                ].contains(statusCode) {
                    do {
                        let decoder = JSONDecoder()
                        let decoded = try decoder.decode(QuarterDayForecastResponse.self, from: data)
                        dispatchQueue.async {
                            completionHandler(.success(decoded), httpResponse)
                        }
                    } catch {
                        dispatchQueue.async {
                            completionHandler(.failure(AzureError.client("Decoding error.", error)), httpResponse)
                        }
                    }
                }
            case .failure:
                do {
                    let decoder = JSONDecoder()
                    let decoded = try decoder.decode(ErrorResponse.self, from: data)
                    dispatchQueue.async {
                        completionHandler(
                            .failure(AzureError.service("An unexpected error occurred.", decoded)),
                            httpResponse
                        )
                    }
                } catch {
                    dispatchQueue.async {
                        completionHandler(.failure(AzureError.client("Decoding error.", error)), httpResponse)
                    }
                }
            }
        }
    }

    /// **Get Current Conditions**
    ///
    ///
    /// **Applies to**: S0 and S1 pricing tiers.
    /// Get Current Conditions service returns detailed current weather conditions such as precipitation, temperature and wind for a given coordinate location. Also, observations from the past 6 or 24 hours for a particular location can be retrieved. The basic information returned with the response include details such as observation date and time, brief description of the weather conditions, weather icon, precipitation indicator flags, and temperature. Additional details such as RealFeel™ Temperature and UV index are also returned.
    /// - Parameters:
    ///    - format : Desired format of the response. Only `json` format is supported.
    ///    - coordinates : The applicable query specified as a comma separated string composed by latitude followed by longitude e.g. "47.641268,-122.125679".
    ///    - options: A list of options for the operation
    ///    - completionHandler: A completion handler that receives a status code on
    ///     success.
    internal func getCurrentConditions(
        format: JsonFormat,
        coordinates: [Double],
        withOptions options: GetCurrentConditionsOptions? = nil,
        completionHandler: @escaping HTTPResultHandler<CurrentConditionsResponse>
    ) {
        let dispatchQueue = options?.dispatchQueue ?? client.commonOptions.dispatchQueue ?? DispatchQueue.main

        // Create request parameters
        let params = RequestParameters(
            (.path, "format", format, .encode),
            (.query, "query", coordinates.map { "\($0)" }.joined(separator: ","), .encode),
            (.query, "unit", options?.unit, .encode), (.query, "details", options?.details, .encode),
            (.query, "duration", options?.duration, .encode), (.query, "language", options?.language, .encode),
            (.uri, "$host", client.endpoint.absoluteString, .skipEncoding),
            (.header, "x-ms-client-id", client.clientId, .encode),
            (.query, "api-version", client.options.apiVersion, .encode),
            (.header, "Accept", "application/json", .encode)
        )

        // Construct request
        let urlTemplate = "/weather/currentConditions/{format}"
        guard let requestUrl = client.url(host: "{$host}", template: urlTemplate, params: params),
            let request = try? HTTPRequest(method: .get, url: requestUrl, headers: params.headers)
        else {
            client.options.logger.error("Failed to construct HTTP request.")
            return
        }

        // Apply client-side validation
        var validationErrors = [String]()
        // Validate coordinates
        if coordinates.count > 2 {
            validationErrors.append("coordinates: maxItems 2")
        }
        if coordinates.count < 2 {
            validationErrors.append("coordinates: minItems 2")
        }
        if !validationErrors.isEmpty {
            dispatchQueue.async {
                let error = AzureError.client("Validation Errors: \(validationErrors.joined(separator: ", "))")
                completionHandler(.failure(error), nil)
            }
            return
        }

        // Send request
        let context = PipelineContext.of(keyValues: [
            ContextKey.allowedStatusCodes.rawValue: [200] as AnyObject
        ])
        context.add(cancellationToken: options?.cancellationToken, applying: client.options)
        context.merge(with: options?.context)
        client.request(request, context: context) { result, httpResponse in
            guard let data = httpResponse?.data else {
                let noDataError = AzureError.client("Response data expected but not found.")
                dispatchQueue.async {
                    completionHandler(.failure(noDataError), httpResponse)
                }
                return
            }
            switch result {
            case .success:
                guard let statusCode = httpResponse?.statusCode else {
                    let noStatusCodeError = AzureError.client("Expected a status code in response but didn't find one.")
                    dispatchQueue.async {
                        completionHandler(.failure(noStatusCodeError), httpResponse)
                    }
                    return
                }
                if [
                    200
                ].contains(statusCode) {
                    do {
                        let decoder = JSONDecoder()
                        let decoded = try decoder.decode(CurrentConditionsResponse.self, from: data)
                        dispatchQueue.async {
                            completionHandler(.success(decoded), httpResponse)
                        }
                    } catch {
                        dispatchQueue.async {
                            completionHandler(.failure(AzureError.client("Decoding error.", error)), httpResponse)
                        }
                    }
                }
            case .failure:
                do {
                    let decoder = JSONDecoder()
                    let decoded = try decoder.decode(ErrorResponse.self, from: data)
                    dispatchQueue.async {
                        completionHandler(
                            .failure(AzureError.service("An unexpected error occurred.", decoded)),
                            httpResponse
                        )
                    }
                } catch {
                    dispatchQueue.async {
                        completionHandler(.failure(AzureError.client("Decoding error.", error)), httpResponse)
                    }
                }
            }
        }
    }

    /// **Get Daily Forecast**
    ///
    ///
    /// **Applies to**: S0 and S1 pricing tiers.
    /// The service returns detailed weather forecast such as temperature and wind by day for the next 1, 5, 10, 15, 25, or 45 days for a given coordinate location.  The response include details such as temperature, wind, precipitation, air quality, and UV index.
    /// In S0 you can request daily forecast for the next 1, 5, 10, and 15 days. In S1 you can also request daily forecast for the next 25 days, and 45 days.
    /// - Parameters:
    ///    - format : Desired format of the response. Only `json` format is supported.
    ///    - coordinates : The applicable query specified as a comma separated string composed by latitude followed by longitude e.g. "47.641268,-122.125679".
    ///    - options: A list of options for the operation
    ///    - completionHandler: A completion handler that receives a status code on
    ///     success.
    internal func getDailyForecast(
        format: JsonFormat,
        coordinates: [Double],
        withOptions options: GetDailyForecastOptions? = nil,
        completionHandler: @escaping HTTPResultHandler<DailyForecastResponse>
    ) {
        let dispatchQueue = options?.dispatchQueue ?? client.commonOptions.dispatchQueue ?? DispatchQueue.main

        // Create request parameters
        let params = RequestParameters(
            (.path, "format", format, .encode),
            (.query, "query", coordinates.map { "\($0)" }.joined(separator: ","), .encode),
            (.query, "unit", options?.unit, .encode), (.query, "duration", options?.duration, .encode),
            (.query, "language", options?.language, .encode),
            (.uri, "$host", client.endpoint.absoluteString, .skipEncoding),
            (.header, "x-ms-client-id", client.clientId, .encode),
            (.query, "api-version", client.options.apiVersion, .encode),
            (.header, "Accept", "application/json", .encode)
        )

        // Construct request
        let urlTemplate = "/weather/forecast/daily/{format}"
        guard let requestUrl = client.url(host: "{$host}", template: urlTemplate, params: params),
            let request = try? HTTPRequest(method: .get, url: requestUrl, headers: params.headers)
        else {
            client.options.logger.error("Failed to construct HTTP request.")
            return
        }

        // Apply client-side validation
        var validationErrors = [String]()
        // Validate coordinates
        if coordinates.count > 2 {
            validationErrors.append("coordinates: maxItems 2")
        }
        if coordinates.count < 2 {
            validationErrors.append("coordinates: minItems 2")
        }
        if !validationErrors.isEmpty {
            dispatchQueue.async {
                let error = AzureError.client("Validation Errors: \(validationErrors.joined(separator: ", "))")
                completionHandler(.failure(error), nil)
            }
            return
        }

        // Send request
        let context = PipelineContext.of(keyValues: [
            ContextKey.allowedStatusCodes.rawValue: [200] as AnyObject
        ])
        context.add(cancellationToken: options?.cancellationToken, applying: client.options)
        context.merge(with: options?.context)
        client.request(request, context: context) { result, httpResponse in
            guard let data = httpResponse?.data else {
                let noDataError = AzureError.client("Response data expected but not found.")
                dispatchQueue.async {
                    completionHandler(.failure(noDataError), httpResponse)
                }
                return
            }
            switch result {
            case .success:
                guard let statusCode = httpResponse?.statusCode else {
                    let noStatusCodeError = AzureError.client("Expected a status code in response but didn't find one.")
                    dispatchQueue.async {
                        completionHandler(.failure(noStatusCodeError), httpResponse)
                    }
                    return
                }
                if [
                    200
                ].contains(statusCode) {
                    do {
                        let decoder = JSONDecoder()
                        let decoded = try decoder.decode(DailyForecastResponse.self, from: data)
                        dispatchQueue.async {
                            completionHandler(.success(decoded), httpResponse)
                        }
                    } catch {
                        dispatchQueue.async {
                            completionHandler(.failure(AzureError.client("Decoding error.", error)), httpResponse)
                        }
                    }
                }
            case .failure:
                do {
                    let decoder = JSONDecoder()
                    let decoded = try decoder.decode(ErrorResponse.self, from: data)
                    dispatchQueue.async {
                        completionHandler(
                            .failure(AzureError.service("An unexpected error occurred.", decoded)),
                            httpResponse
                        )
                    }
                } catch {
                    dispatchQueue.async {
                        completionHandler(.failure(AzureError.client("Decoding error.", error)), httpResponse)
                    }
                }
            }
        }
    }

    /// **Get Weather along route**
    ///
    ///
    ///  **Applies to**: S1 pricing tier.
    ///  Weather along a route API returns hyper local (one kilometer or less), up-to-the-minute weather nowcasts, weather hazard assessments, and notifications along a route described as a sequence of waypoints.
    ///  This includes a list of weather hazards affecting the waypoint or route, and the aggregated hazard index for each waypoint might be used to paint each portion of a route according to how safe it is for the driver. When submitting the waypoints, it is recommended to stay within, or close to, the distance that can be traveled within 120-mins or shortly after. Data is updated every five minutes.
    ///
    ///  The service supplements Azure Maps [Route Service](https://docs.microsoft.com/rest/api/maps/route) that allows you to first request a route between an origin and a destination and use that as an input for Weather Along Route endpoint.
    ///
    ///  In addition, the service supports scenarios to generate weather notifications for waypoints that experience an increase in intensity of a weather hazard. For example, if the vehicle is expected to begin experiencing heavy rain as it reaches a waypoint, a weather notification for heavy rain will be generated for that waypoint allowing the end product to display a heavy rain notification before the driver reaches that waypoint.
    ///  The trigger for when to display the notification for a waypoint could be based, for example, on a [geofence](https://docs.microsoft.com/azure/azure-maps/tutorial-iot-hub-maps), or selectable distance to the waypoint.
    ///  The API covers all regions of the planet except latitudes above Greenland and Antarctica.
    /// - Parameters:
    ///    - format : Desired format of the response. Only `json` format is supported.
    ///    - query : Coordinates through which the route is calculated, separated by colon (:) and entered in chronological order. A minimum of two waypoints is required. A single API call may contain up to 60 waypoints.
    /// A waypoint indicates location, ETA, and optional heading: latitude,longitude,ETA,heading, where
    ///   * `Latitude` - Latitude coordinate in decimal degrees.
    ///   * `Longitude` - Longitude coordinate in decimal degrees.
    ///   * `ETA (estimated time of arrival)` - The number of minutes from the present time that it will take for the vehicle to reach the waypoint. Allowed range is from 0.0 to 120.0 minutes.
    ///   * `Heading` - An optional value indicating the vehicle heading as it passes the waypoint. Expressed in clockwise degrees relative to true north. This is issued to calculate sun glare as a driving hazard. Allowed range is from 0.0 to 360.0 degrees. If not provided, a heading will automatically be derived based on the position of neighboring waypoints.
    /// It is recommended to stay within, or close to, the distance that can be traveled within 120-mins or shortly after. This way a more accurate assessment can be provided for the trip and prevent isolated events not being captured between waypoints.  Information can and should be updated along the route (especially for trips greater than 2 hours) to continuously pull new waypoints moving forward, but also to ensure that forecast information for content such as precipitation type and intensity is accurate as storms develop and dissipate over time.
    ///    - options: A list of options for the operation
    ///    - completionHandler: A completion handler that receives a status code on
    ///     success.
    internal func getWeatherAlongRoute(
        format: JsonFormat,
        query: String,
        withOptions options: GetWeatherAlongRouteOptions? = nil,
        completionHandler: @escaping HTTPResultHandler<WeatherAlongRouteResponse>
    ) {
        let dispatchQueue = options?.dispatchQueue ?? client.commonOptions.dispatchQueue ?? DispatchQueue.main

        // Create request parameters
        let params = RequestParameters(
            (.path, "format", format, .encode), (.query, "query", query, .encode),
            (.query, "language", options?.language, .encode),
            (.uri, "$host", client.endpoint.absoluteString, .skipEncoding),
            (.header, "x-ms-client-id", client.clientId, .encode),
            (.query, "api-version", client.options.apiVersion, .encode),
            (.header, "Accept", "application/json", .encode)
        )

        // Construct request
        let urlTemplate = "/weather/route/{format}"
        guard let requestUrl = client.url(host: "{$host}", template: urlTemplate, params: params),
            let request = try? HTTPRequest(method: .get, url: requestUrl, headers: params.headers)
        else {
            client.options.logger.error("Failed to construct HTTP request.")
            return
        }

        // Send request
        let context = PipelineContext.of(keyValues: [
            ContextKey.allowedStatusCodes.rawValue: [200] as AnyObject
        ])
        context.add(cancellationToken: options?.cancellationToken, applying: client.options)
        context.merge(with: options?.context)
        client.request(request, context: context) { result, httpResponse in
            guard let data = httpResponse?.data else {
                let noDataError = AzureError.client("Response data expected but not found.")
                dispatchQueue.async {
                    completionHandler(.failure(noDataError), httpResponse)
                }
                return
            }
            switch result {
            case .success:
                guard let statusCode = httpResponse?.statusCode else {
                    let noStatusCodeError = AzureError.client("Expected a status code in response but didn't find one.")
                    dispatchQueue.async {
                        completionHandler(.failure(noStatusCodeError), httpResponse)
                    }
                    return
                }
                if [
                    200
                ].contains(statusCode) {
                    do {
                        let decoder = JSONDecoder()
                        let decoded = try decoder.decode(WeatherAlongRouteResponse.self, from: data)
                        dispatchQueue.async {
                            completionHandler(.success(decoded), httpResponse)
                        }
                    } catch {
                        dispatchQueue.async {
                            completionHandler(.failure(AzureError.client("Decoding error.", error)), httpResponse)
                        }
                    }
                }
            case .failure:
                do {
                    let decoder = JSONDecoder()
                    let decoded = try decoder.decode(ErrorResponse.self, from: data)
                    dispatchQueue.async {
                        completionHandler(
                            .failure(AzureError.service("An unexpected error occurred.", decoded)),
                            httpResponse
                        )
                    }
                } catch {
                    dispatchQueue.async {
                        completionHandler(.failure(AzureError.client("Decoding error.", error)), httpResponse)
                    }
                }
            }
        }
    }

    /// **Get Severe Weather Alerts**
    /// **Applies to**: S0 and S1 pricing tiers.
    /// Severe weather phenomenon can significantly impact our everyday life and business operations. For example, severe weather conditions such as tropical storms, high winds or flooding can close roads and force logistics companies to reroute their fleet causing delays in reaching destinations and breaking the cold chain of refrigerated food products.  Azure Maps Severe Weather Alerts API returns the severe weather alerts that are available worldwide from both official Government Meteorological Agencies and leading global to regional weather alert providers. The service can return details such as alert type, category, level and detailed description about the active severe alerts for the requested location, like hurricanes, thunderstorms, lightning, heat waves or forest fires.
    /// - Parameters:
    ///    - format : Desired format of the response. Only `json` format is supported.
    ///    - coordinates : The applicable query specified as a comma separated string composed by latitude followed by longitude e.g. "47.641268,-122.125679".
    ///    - options: A list of options for the operation
    ///    - completionHandler: A completion handler that receives a status code on
    ///     success.
    internal func getSevereWeatherAlerts(
        format: JsonFormat,
        coordinates: [Double],
        withOptions options: GetSevereWeatherAlertsOptions? = nil,
        completionHandler: @escaping HTTPResultHandler<SevereWeatherAlertsResponse>
    ) {
        let dispatchQueue = options?.dispatchQueue ?? client.commonOptions.dispatchQueue ?? DispatchQueue.main

        // Create request parameters
        let params = RequestParameters(
            (.path, "format", format, .encode),
            (.query, "query", coordinates.map { "\($0)" }.joined(separator: ","), .encode),
            (.query, "language", options?.language, .encode), (.query, "details", options?.details, .encode),
            (.uri, "$host", client.endpoint.absoluteString, .skipEncoding),
            (.header, "x-ms-client-id", client.clientId, .encode),
            (.query, "api-version", client.options.apiVersion, .encode),
            (.header, "Accept", "application/json", .encode)
        )

        // Construct request
        let urlTemplate = "/weather/severe/alerts/{format}"
        guard let requestUrl = client.url(host: "{$host}", template: urlTemplate, params: params),
            let request = try? HTTPRequest(method: .get, url: requestUrl, headers: params.headers)
        else {
            client.options.logger.error("Failed to construct HTTP request.")
            return
        }

        // Apply client-side validation
        var validationErrors = [String]()
        // Validate coordinates
        if coordinates.count > 2 {
            validationErrors.append("coordinates: maxItems 2")
        }
        if coordinates.count < 2 {
            validationErrors.append("coordinates: minItems 2")
        }
        if !validationErrors.isEmpty {
            dispatchQueue.async {
                let error = AzureError.client("Validation Errors: \(validationErrors.joined(separator: ", "))")
                completionHandler(.failure(error), nil)
            }
            return
        }

        // Send request
        let context = PipelineContext.of(keyValues: [
            ContextKey.allowedStatusCodes.rawValue: [200] as AnyObject
        ])
        context.add(cancellationToken: options?.cancellationToken, applying: client.options)
        context.merge(with: options?.context)
        client.request(request, context: context) { result, httpResponse in
            guard let data = httpResponse?.data else {
                let noDataError = AzureError.client("Response data expected but not found.")
                dispatchQueue.async {
                    completionHandler(.failure(noDataError), httpResponse)
                }
                return
            }
            switch result {
            case .success:
                guard let statusCode = httpResponse?.statusCode else {
                    let noStatusCodeError = AzureError.client("Expected a status code in response but didn't find one.")
                    dispatchQueue.async {
                        completionHandler(.failure(noStatusCodeError), httpResponse)
                    }
                    return
                }
                if [
                    200
                ].contains(statusCode) {
                    do {
                        let decoder = JSONDecoder()
                        let decoded = try decoder.decode(SevereWeatherAlertsResponse.self, from: data)
                        dispatchQueue.async {
                            completionHandler(.success(decoded), httpResponse)
                        }
                    } catch {
                        dispatchQueue.async {
                            completionHandler(.failure(AzureError.client("Decoding error.", error)), httpResponse)
                        }
                    }
                }
            case .failure:
                do {
                    let decoder = JSONDecoder()
                    let decoded = try decoder.decode(ErrorResponse.self, from: data)
                    dispatchQueue.async {
                        completionHandler(
                            .failure(AzureError.service("An unexpected error occurred.", decoded)),
                            httpResponse
                        )
                    }
                } catch {
                    dispatchQueue.async {
                        completionHandler(.failure(AzureError.client("Decoding error.", error)), httpResponse)
                    }
                }
            }
        }
    }

    /// **Get Daily Indices**
    /// **Applies to**: S0 and S1 pricing tiers.
    /// There may be times when you want to know if the weather conditions are optimal for a specific activity, for example, for outdoor construction, indoor activities, running or farming including soil moisture information.  Azure Maps Indices API returns index values that will guide end users to plan future activities. For example, a health mobile application can notify users that today is good weather for running or for other outdoors activities like for playing golf, and retail stores can optimize their digital marketing campaigns based on predicted index values. The service returns in daily indices values for current and next 5, 10 and 15 days starting from current day.
    /// - Parameters:
    ///    - format : Desired format of the response. Only `json` format is supported.
    ///    - coordinates : The applicable query specified as a comma separated string composed by latitude followed by longitude e.g. "47.641268,-122.125679".
    ///    - options: A list of options for the operation
    ///    - completionHandler: A completion handler that receives a status code on
    ///     success.
    internal func getDailyIndices(
        format: JsonFormat,
        coordinates: [Double],
        withOptions options: GetDailyIndicesOptions? = nil,
        completionHandler: @escaping HTTPResultHandler<DailyIndicesResponse>
    ) {
        let dispatchQueue = options?.dispatchQueue ?? client.commonOptions.dispatchQueue ?? DispatchQueue.main

        // Create request parameters
        let params = RequestParameters(
            (.path, "format", format, .encode),
            (.query, "query", coordinates.map { "\($0)" }.joined(separator: ","), .encode),
            (.query, "language", options?.language, .encode), (.query, "duration", options?.duration, .encode),
            (.query, "indexId", options?.indexId, .encode), (.query, "indexGroupId", options?.indexGroupId, .encode),
            (.uri, "$host", client.endpoint.absoluteString, .skipEncoding),
            (.header, "x-ms-client-id", client.clientId, .encode),
            (.query, "api-version", client.options.apiVersion, .encode),
            (.header, "Accept", "application/json", .encode)
        )

        // Construct request
        let urlTemplate = "/weather/indices/daily/{format}"
        guard let requestUrl = client.url(host: "{$host}", template: urlTemplate, params: params),
            let request = try? HTTPRequest(method: .get, url: requestUrl, headers: params.headers)
        else {
            client.options.logger.error("Failed to construct HTTP request.")
            return
        }

        // Apply client-side validation
        var validationErrors = [String]()
        // Validate coordinates
        if coordinates.count > 2 {
            validationErrors.append("coordinates: maxItems 2")
        }
        if coordinates.count < 2 {
            validationErrors.append("coordinates: minItems 2")
        }
        if !validationErrors.isEmpty {
            dispatchQueue.async {
                let error = AzureError.client("Validation Errors: \(validationErrors.joined(separator: ", "))")
                completionHandler(.failure(error), nil)
            }
            return
        }

        // Send request
        let context = PipelineContext.of(keyValues: [
            ContextKey.allowedStatusCodes.rawValue: [200] as AnyObject
        ])
        context.add(cancellationToken: options?.cancellationToken, applying: client.options)
        context.merge(with: options?.context)
        client.request(request, context: context) { result, httpResponse in
            guard let data = httpResponse?.data else {
                let noDataError = AzureError.client("Response data expected but not found.")
                dispatchQueue.async {
                    completionHandler(.failure(noDataError), httpResponse)
                }
                return
            }
            switch result {
            case .success:
                guard let statusCode = httpResponse?.statusCode else {
                    let noStatusCodeError = AzureError.client("Expected a status code in response but didn't find one.")
                    dispatchQueue.async {
                        completionHandler(.failure(noStatusCodeError), httpResponse)
                    }
                    return
                }
                if [
                    200
                ].contains(statusCode) {
                    do {
                        let decoder = JSONDecoder()
                        let decoded = try decoder.decode(DailyIndicesResponse.self, from: data)
                        dispatchQueue.async {
                            completionHandler(.success(decoded), httpResponse)
                        }
                    } catch {
                        dispatchQueue.async {
                            completionHandler(.failure(AzureError.client("Decoding error.", error)), httpResponse)
                        }
                    }
                }
            case .failure:
                do {
                    let decoder = JSONDecoder()
                    let decoded = try decoder.decode(ErrorResponse.self, from: data)
                    dispatchQueue.async {
                        completionHandler(
                            .failure(AzureError.service("An unexpected error occurred.", decoded)),
                            httpResponse
                        )
                    }
                } catch {
                    dispatchQueue.async {
                        completionHandler(.failure(AzureError.client("Decoding error.", error)), httpResponse)
                    }
                }
            }
        }
    }
}
